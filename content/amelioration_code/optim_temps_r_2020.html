---
title: "Optimisation de temps d'exécution en R"
linkTitle: "Optimisation temps exécution R"
author: "Sophie Baillargeon, Université Laval"
date: "2020-03-31"
weight: 2
slug: "optim_temps_r"
categories: ["cours_2020-04-07"]
categories_weight: 1
lastmodifierdisplayname: "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    highlight: tango
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    highlight: tango
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
- \renewcommand{\linethickness}{0.05em}
- \usepackage{ragged2e}
editor_options: 
  chunk_output_type: console
---






<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { background-color: #f8f8f8; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#outils-danalyse-de-la-performance-dun-programme-r">Outils d’analyse de la performance d’un programme R</a><ul>
<li><a href="#fonction-system.time">Fonction <code>system.time</code></a></li>
<li><a href="#package-bench">Package <code>bench</code></a></li>
<li><a href="#liens-entre-gestion-de-la-mémoire-et-temps-dexécution">Liens entre gestion de la mémoire et temps d’exécution</a><ul>
<li><a href="#récupération-de-mémoire-garbage-collection">Récupération de mémoire (<em>garbage collection</em>)</a></li>
</ul></li>
<li><a href="#fonctions-rprof-et-summaryrprof">Fonctions <code>Rprof</code> et <code>summaryRprof</code></a></li>
<li><a href="#package-profvis">Package <code>profvis</code></a></li>
</ul></li>
<li><a href="#stratégies-doptimisation-du-temps-dexécution">Stratégies d’optimisation du temps d’exécution</a><ul>
<li><a href="#astuce-1-utiliser-des-fonctions-optimisées">Astuce 1 : Utiliser des fonctions optimisées</a></li>
<li><a href="#astuce-2-faire-seulement-ce-qui-est-nécessaire">Astuce 2 : Faire seulement ce qui est nécessaire</a></li>
<li><a href="#astuce-3-exploiter-les-calculs-matriciels-et-vectoriels">Astuce 3 : Exploiter les calculs matriciels et vectoriels</a></li>
<li><a href="#astuce-4-éviter-les-allocations-de-mémoire-inutiles">Astuce 4 : Éviter les allocations de mémoire inutiles</a><ul>
<li><a href="#objets-de-dimension-croissante">Objets de dimension croissante</a></li>
<li><a href="#modification-déléments-dans-un-data-frame">Modification d’éléments dans un data frame</a></li>
</ul></li>
<li><a href="#astuce-5-faire-du-calcul-en-parallèle">Astuce 5 : Faire du calcul en parallèle</a></li>
<li><a href="#astuce-6-reprogrammer-en-c-ou-c-les-bouts-de-code-les-plus-lents">Astuce 6 : Reprogrammer en C ou C++ les bouts de code les plus lents</a></li>
</ul></li>
<li><a href="#résumé">Résumé</a></li>
<li><a href="#références">Références</a></li>
</ul>
</div>

<hr />
<p>Lorsque nous écrivons du code, notre but premier est évidemment que ce code fonctionne correctement. Après avoir vérifié que le code <a href="https://stt4230.rbind.io/programmation/tests_exceptions_r/">produit les résultats escomptés et gère correctement les exceptions</a>, nous devrions, selon les <a href="https://stt4230.rbind.io/amelioration_code/bonnes_pratiques_r/">bonnes pratiques</a>, nous assurer que le code est facile à maintenir (écriture, compréhension et réutilisation aisées). Si notre code remplit toutes les conditions énumérées ci-dessus, mais que son temps d’exécution est long, nous devrions envisager de le rendre plus rapide, sans quoi il risque d’être peu ou pas utilisé. Cependant, n’oublions pas qu’il est inutile d’optimiser le temps d’exécution d’un programme roulant déjà suffisamment rapidement.</p>
<p>Pour réduire le temps d’exécution d’un programme, il faut d’abord cerner la partie du programme responsable des lenteurs. Pour ce faire, il est conseillé d’utiliser des outils qui analysent la performance du code. Après avoir cerné les instructions problématiques, il faut les modifier de façon à effectuer le calcul plus rapidement. Certains outils d’analyse de performance sont présentés dans ce qui suit. Ensuite, nous verrons des stratégies d’optimisation de temps d’exécution.</p>
<div style="page-break-after: always;"></div>
<div id="outils-danalyse-de-la-performance-dun-programme-r" class="section level1">
<h1>Outils d’analyse de la performance d’un programme R</h1>
<p>Une analyse de la performance d’un programme informatique est appelée <a href="https://fr.wikipedia.org/wiki/Profilage_de_code">profilage de code</a> (en anglais <em>code profiling</em>). Il est possible de profiler l’utilisation du processeur et l’utilisation de la mémoire. Nous nous attarderons surtout ici au profilage de l’utilisation du processeur, qui vise principalement à évaluer le temps d’exécution d’un programme. Cependant, nous parlerons aussi un peu de profilage d’utilisation de la mémoire, car la gestion de la mémoire a un impact sur le temps d’exécution.</p>
<p>Le R de base propose deux outils pour effectuer du profilage d’utilisation du processeur :</p>
<ul>
<li>la fonction <code>system.time</code> : pour le calcul de temps global d’exécution;</li>
<li>les fonctions <code>Rprof</code> et <code>summaryRprof</code> : pour décortiquer la provenance des lenteurs dans un code R.</li>
</ul>
<p>Cependant, ces fonctions sont souvent insuffisantes pour réaliser une analyse approfondie. Nous utiliserons aussi les packages suivants :</p>
<ul>
<li><code>bench</code> : pour le calcul de temps global d’exécution et un suivi de la gestion de la mémoire;</li>
<li><code>profvis</code> : pour visualiser le résultat produit par <code>Rprof</code>.</li>
</ul>
<p>Pour illustrer l’utilisation de ces fonctions, nous allons reprendre un exemple des <a href="https://stt4230.rbind.io/programmation/fonctions_r/#exemple-de-cr%C3%A9ation-dune-fonction-r">notes sur les fonctions en R</a>. Nous avions créé les deux fonctions suivantes pour compter combien de nombres entiers impairs contient un vecteur numérique<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="co">#&#39; @title Compte le nombre d&#39;entiers impairs dans un vecteur numérique</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">#&#39; @description Version avec calcul vectoriel</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">#&#39; @param x vecteur numérique</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">#&#39; @return le nombre de nombres entiers impairs dans x</span></a>
<a class="sourceLine" id="cb1-5" title="5">compte_impair_vectoriel &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="kw">sum</span>(x <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-7" title="7">}</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1"><span class="co">#&#39; @title Compte le nombre d&#39;entiers impairs dans un vecteur numérique</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">#&#39; @description Version avec boucle</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">#&#39; @inherit compte_impair_vectoriel params return</span></a>
<a class="sourceLine" id="cb2-4" title="4">compte_impair_boucle &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb2-5" title="5">  k &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="cf">for</span> (n <span class="cf">in</span> x) {</a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="cf">if</span> (n <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb2-8" title="8">      k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb2-9" title="9">    }</a>
<a class="sourceLine" id="cb2-10" title="10">  }</a>
<a class="sourceLine" id="cb2-11" title="11">  k</a>
<a class="sourceLine" id="cb2-12" title="12">}</a></code></pre></div>
<p>Des <a href="https://stt4230.rbind.io/packages/devel_packages_r/#comment-ecrire-de-la-documentation-avec-roxygen2">tags <code>roxygen2</code></a> sont utilisés pour documenter les fonctions. Cependant, les commentaires <code>roxygen2</code> écrits ici ne formeraient pas des fiches d’aide complètes. Ce n’est pas un problème puisque nous n’avons pas l’intention de créer un package avec ces fonctions. Notons que le <a href="https://roxygen2.r-lib.org/articles/rd.html#do-repeat-yourself">tag <code>@inherit</code></a> permet de reprendre telles quelles des sections d’une autre fiche d’aide, ici la description des arguments et de la sortie.</p>
<p>Avant de profiler ces fonctions, assurons-nous qu’elles retournent le même résultat. Pour ce faire, donnons-leur en entrée un vecteur <code>obs</code> contenant un million d’observations générées aléatoirement.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="co"># Génération aléatoire d&#39;un million d&#39;observations</span></a>
<a class="sourceLine" id="cb3-2" title="2">obs &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">runif</span>(<span class="dv">1000000</span>, <span class="dv">-10</span>, <span class="dv">10</span>))</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># Appels aux fonctions à comparer</span></a>
<a class="sourceLine" id="cb4-2" title="2">compte_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">compte_impair_vectoriel</span>(<span class="dt">x =</span> obs)</a>
<a class="sourceLine" id="cb4-3" title="3">compte_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">compte_impair_boucle</span>(<span class="dt">x =</span> obs)</a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># Comparaison des sorties retournées</span></a>
<a class="sourceLine" id="cb5-2" title="2">compte_<span class="dv">1</span> <span class="op">==</span><span class="st"> </span>compte_<span class="dv">2</span></a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Les deux fonctions retournent bien dans cet exemple la même valeur numérique. Notons cependant que la première fonction (<code>compte_impair_vectoriel</code>) retourne le résultat sous la forme d’un entier (<em>integer</em>) et la deuxième (<code>compte_impair_boucle</code>) sous la forme d’un réel (<em>double</em>). Cette différence de type de donnée retournée n’est pas un problème ici.</p>
<div id="fonction-system.time" class="section level2">
<h2>Fonction <code>system.time</code></h2>
<p>Mesurons combien de temps prennent les exécutions d’appels aux fonctions <code>compte_impair_vectoriel</code> et <code>compte_impair_boucle</code> lorsque nous leur donnons en entrée le vecteur <code>obs</code>. Pour ce faire, utilisons d’abord la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/system.time.html">fonction <code>system.time</code></a>, comme nous l’avions fait dans les <a href="https://stt4230.rbind.io/programmation/fonctions_r/#exemple-de-cr%C3%A9ation-dune-fonction-r">notes sur les fonctions en R</a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1">temps_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">system.time</span>(compte_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">compte_impair_vectoriel</span>(<span class="dt">x =</span> obs))</a>
<a class="sourceLine" id="cb7-2" title="2">temps_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">system.time</span>(compte_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">compte_impair_boucle</span>(<span class="dt">x =</span> obs))</a></code></pre></div>
<p>Il faut donner en entrée à <code>system.time</code> une instruction R, contenant ou non une assignation, ou encore des instructions R encadrées d’accolades. Cet ensemble d’instruction(s) est appelé <em>expression</em>. La fonction retourne le temps, en secondes, d’utilisation du CPU (<em>Central Processing Unit</em>) pour l’exécution de l’expression. Notons que le terme « exécution » pourrait être remplacé par le terme « évaluation ». Ils ont ici la même signification.</p>
<p>J’obtiens les temps suivants, qui indiquent que <code>compte_impair_vectoriel</code> est plus rapide que <code>compte_impair_boucle</code> :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">temps_<span class="dv">1</span></a></code></pre></div>
<pre><code>##    user  system elapsed 
##    0.06    0.00    0.07</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">temps_<span class="dv">2</span></a></code></pre></div>
<pre><code>##    user  system elapsed 
##    0.28    0.00    0.30</code></pre>
<p>Les trois temps dans une sortie produite par <code>system.time</code> peuvent être définis ainsi :</p>
<ul>
<li><code>user</code> : temps écoulé par le logiciel R (<em>calling process</em>) pour évaluer l’expression;</li>
<li><code>system</code> : temps écoulé par le système d’exploitation de notre ordinateur, mais pour le compte du logiciel R, pendant l’exécution de l’expression;</li>
<li><code>elapsed</code> : temps total écoulé entre la soumission de l’expression et le retour du résultat (possiblement plus grand que la somme des deux autres temps, car le système a peut-être dû accorder du temps à d’autres processus actifs sur l’ordinateur pendant l’exécution de l’expression)</li>
</ul>
<p>Les temps d’exécution obtenus dépendent des spécifications de l’ordinateur utilisé, en particulier de la puissance de son CPU. De plus, nous n’obtiendrons probablement pas exactement les mêmes temps si nous évaluons à nouveau l’expression. Il y a une petite variation normale du temps d’exécution, causée notamment par les autres processus utilisant le CPU de notre ordinateur au moment où la commande est lancée.</p>
</div>
<div id="package-bench" class="section level2">
<h2>Package <code>bench</code></h2>
<p>La fonction <code>system.time</code> est plutôt minimaliste. Elle mesure le temps pris par une seule exécution d’une expression. Pour évaluer plus justement le temps d’exécution d’une expression, il est préférable de l’exécuter à quelques reprises, puis de calculer le temps médian d’exécution. La médiane est plus appropriée que la moyenne pour cette mesure de tendance centrale, car elle est robuste aux valeurs extrêmes, qui ne sont pas si rares parmi des temps d’exécution. Aussi, étant donné qu’il y a un lien entre le temps d’exécution et la gestion de la mémoire, il serait pertinent de récolter, en plus du temps, des informations concernant la mémoire utilisée pendant les exécutions. Voilà le but du <a href="http://bench.r-lib.org/">package <code>bench</code></a>. Dans ces notes, nous allons utiliser la <a href="http://bench.r-lib.org/reference/mark.html">fonction <code>mark</code></a> de ce package pour effectuer du profilage de plusieurs fonctions R.</p>
<p>Comparativement à la fonction <code>system.time</code>, la fonction <code>mark</code> possède plusieurs avantages, notamment :</p>
<ul>
<li>profilage de plus d’une expression à la fois;</li>
<li>chronométrage plus précis grâce aux répétitions et à une unité de mesure de temps plus fine;</li>
<li>suivi de la gestion de la mémoire.</li>
</ul>
<p>Voici un premier exemple d’utilisation de cette fonction :</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">library</span>(bench)</a></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" title="1">sortie_mark &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="dt">vectoriel =</span> <span class="kw">compte_impair_vectoriel</span>(obs), </a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="dt">boucle =</span> <span class="kw">compte_impair_boucle</span>(obs)</a>
<a class="sourceLine" id="cb13-4" title="4">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<p>Un avertissement a été émis. Nous y reviendrons.</p>
<p>Il faut fournir en entrée à cette fonction une série d’expressions à profiler (ce pourrait être une seule expression). Ces expressions sont à fournir en arguments distincts, attrapés par l’argument <code>...</code>, qui permet le passage d’autant d’expressions à profiler que souhaité. Les expressions peuvent être assignées à des noms avec l’opérateur <code>=</code> (comme dans l’exemple), ou non. Le nom fourni à gauche de l’opérateur <code>=</code> pour une expression est celui utilisé pour identifier l’expression dans la sortie, ce qui peut aider à alléger l’affichage des résultats.</p>
<p>La sortie retournée par la fonction <code>mark</code> a un format particulier. Il s’agit d’un objet possédant 4 classes, dont celle de data frame, mais pour lequel les éléments ne sont pas tous de simples vecteurs ou facteur.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">class</span>(sortie_mark)</a></code></pre></div>
<pre><code>## [1] &quot;bench_mark&quot; &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" title="1">sortie_mark</a></code></pre></div>
<pre><code>## # A tibble: 2 x 13
##   expression     min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time
##   &lt;bch:expr&gt; &lt;bch:t&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;   &lt;bch:tm&gt;
## 1 vectoriel   42.6ms  51.3ms     19.9     11.4MB     3.98    10     2      502ms
## 2 boucle     277.4ms 281.7ms      3.55        0B    23.1      2    13      563ms
## # ... with 4 more variables: result &lt;list&gt;, memory &lt;list&gt;, time &lt;list&gt;, gc &lt;list&gt;</code></pre>
<p>Pour simplifier l’analyse des résultats retournés par <code>mark</code>, je vais utiliser la fonction suivante pour imprimer les sorties produites par cette fonction dans le reste de ces notes.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" title="1"><span class="co">#&#39; @title Impression simplifiée d&#39;une sortie de bench::mark</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="co">#&#39; @description Conserve six éléments et imprime sous forme de data frame</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="co">#&#39; @param x sortie produite par bench::mark</span></a>
<a class="sourceLine" id="cb19-4" title="4">print_bench_mark &lt;-<span class="st"> </span><span class="cf">function</span>(x){</a>
<a class="sourceLine" id="cb19-5" title="5">  df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="dt">expression =</span> <span class="kw">as.character</span>(x<span class="op">$</span>expression),</a>
<a class="sourceLine" id="cb19-7" title="7">    <span class="dt">n_itr =</span> x<span class="op">$</span>n_itr,</a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="dt">min =</span> <span class="cf">if</span> (<span class="kw">inherits</span>(x<span class="op">$</span>min, <span class="st">&quot;bench_time&quot;</span>)) <span class="kw">as.character</span>(x<span class="op">$</span>min) <span class="cf">else</span> x<span class="op">$</span>min,</a>
<a class="sourceLine" id="cb19-9" title="9">    <span class="dt">median =</span> <span class="cf">if</span> (<span class="kw">inherits</span>(x<span class="op">$</span>min, <span class="st">&quot;bench_time&quot;</span>)) <span class="kw">as.character</span>(x<span class="op">$</span>median) <span class="cf">else</span> x<span class="op">$</span>median,</a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="dt">mem_alloc =</span> <span class="kw">as.character</span>(x<span class="op">$</span>mem_alloc),</a>
<a class="sourceLine" id="cb19-11" title="11">    <span class="dt">n_gc =</span> x<span class="op">$</span>n_gc,</a>
<a class="sourceLine" id="cb19-12" title="12">    <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb19-13" title="13">  )</a>
<a class="sourceLine" id="cb19-14" title="14">  <span class="kw">print</span>(df)</a>
<a class="sourceLine" id="cb19-15" title="15">  <span class="kw">invisible</span>(df)</a>
<a class="sourceLine" id="cb19-16" title="16">}</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">print_bench_mark</span>(sortie_mark)</a></code></pre></div>
<pre><code>##   expression n_itr     min  median mem_alloc n_gc
## 1  vectoriel    10  42.6ms  51.3ms    11.4MB    2
## 2     boucle     2 277.4ms 281.7ms        0B   13</code></pre>
<p>Dans cette sortie, possédant une ligne par expression à profiler, les différentes colonnes contiennent :</p>
<ul>
<li><code>expression</code> : identifiant de l’expression,</li>
<li><code>n_itr</code> : nombre de répétitions (ou itérations) de l’exécution de l’expression,</li>
<li><code>min</code> : temps pris par l’exécution la plus rapide de l’expression,</li>
<li><code>median</code> : temps médian d’exécution parmi les répétitions,</li>
<li><code>mem_alloc</code> : quantité totale de mémoire allouée pendant une exécution de l’expression,</li>
<li><code>n_gc</code> : nombre total de récupérations de mémoire (en anglais <em>garbage collections</em>, d’où l’abréviation <code>gc</code>) effectuées pendant toutes les répétitions d’exécution.</li>
</ul>
<p>Dans cet exemple, la fonction <code>compte_impair_vectoriel</code> est beaucoup plus rapide que la fonction <code>compte_impair_boucle</code> (temps médians de 51.3ms = 0.0513 secondes versus 281.7ms = 0.2817 secondes), mais elle utilise plus de mémoire (11.4MB = 1.200009610^{7} bytes versus 0B = 0 bytes).</p>
<p>Les unités de temps et de mémoire sont adaptées de façon à ce que les nombres imprimés ne soient pas trop gros, ni trop petits. Ici, la fonction <code>mark</code> a choisi de mesurer le temps en millisecondes (ms).
Nous aurions pu demander à <code>mark</code> d’utiliser des unités de temps aussi petites que des nanosecondes (ns) via son argument <code>time_unit</code>. Remarquez que ces unités peuvent varier d’une expression à l’autre, comme c’est le cas pour les unités de mémoire dans l’exemple.</p>
<p>La fonction <code>mark</code> sélectionne de façon automatique le nombre de fois qu’est répétée (ou itérée) l’exécution de chacune des expressions. Nous pouvons aussi contrôler ce nombre de répétitions à l’aide des arguments <code>iterations</code>, <code>min_iterations</code> et <code>max_iterations</code>. Pour nous assurer d’effectuer toujours au moins 10 répétitions, nous utiliserons à l’avenir l’argument <code>min_iterations = 10</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" title="1">sortie_mark &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="kw">compte_impair_vectoriel</span>(obs), </a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="kw">compte_impair_boucle</span>(obs),</a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="dt">min_iterations =</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb22-5" title="5">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">print_bench_mark</span>(sortie_mark)</a></code></pre></div>
<pre><code>##                     expression n_itr     min  median mem_alloc n_gc
## 1 compte_impair_vectoriel(obs)    11  35.9ms  49.3ms    11.4MB    3
## 2    compte_impair_boucle(obs)    10 231.7ms 291.4ms        0B   74</code></pre>
<p>Le message d’avertissement <code>"Some expressions had a GC in every iteration; so filtering is disabled."</code>, obtenu lors des deux appels précédents à la fonction <code>mark</code> n’est pas problématique. Dans le calcul du temps médian, la fonction <code>mark</code> cherche à considérer seulement les exécutions pendant lesquelles de la récupération de mémoire n’a pas eu lieu, car celle-ci ralentit l’exécution. Elle est contrainte à ne pas effectuer ce filtrage si toutes les exécutions d’une expression ont subi de la récupération de mémoire. La section suivante explique ce qu’est la récupération de mémoire.</p>
<p>Avant de terminer, le package <code>bench</code> offre même une <a href="http://bench.r-lib.org/reference/autoplot.bench_mark.html">méthode pour la fonction générique <code>plot</code></a> permettant de représenter graphiquement les résultats du profilage.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">plot</span>(sortie_mark)</a></code></pre></div>
<p><img src="/amelioration_code/optim_temps_r_2020_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Pour plus d’informations concernant ce graphique et d’autres possibilités du package <code>bench</code>, le lecteur est référé à la documentation du package : <a href="http://bench.r-lib.org/" class="uri">http://bench.r-lib.org/</a>.</p>
</div>
<div id="liens-entre-gestion-de-la-mémoire-et-temps-dexécution" class="section level2">
<h2>Liens entre gestion de la mémoire et temps d’exécution</h2>
<p>Il n’est pas rare en R que des solutions soient rapides, mais utilisent beaucoup de mémoire. Comme illustré dans l’exemple précédent, et comme nous l’illustrerons une autre fois plus loin dans ces notes, les calculs matriciels et vectoriels sont souvent des options de calcul optimisés en R. Cependant, ils impliquent la création de matrices ou de vecteurs contenant potentiellement un grand nombre d’éléments. Ainsi, la rapidité a parfois un envers : l’utilisation d’une grande quantité de mémoire. Nous verrons que cette contrepartie peut devenir problématique lors du traitement d’une grande quantité de données. Il faut parfois gérer un compromis entre temps d’exécution et quantité de mémoire utilisée.</p>
<p>Aussi, l’opération d’allouer de l’espace dans la mémoire d’un ordinateur pour stocker des données prend un certain temps à être réalisée. Un programme R qui génère de nombreuses allocations en mémoire aura tendance à être lent. Une des stratégies présentées ici identifie des opérations à éviter en raison du grand nombre d’allocations en mémoire qu’elles provoquent.</p>
<div id="récupération-de-mémoire-garbage-collection" class="section level3">
<h3>Récupération de mémoire (<em>garbage collection</em>)</h3>
<p>Étant donné que les allocations et désallocations de mémoire en R sont réalisées de façon implicite plutôt qu’explicitement par l’utilisateur comme dans certains langages informatiques (p. ex. en C), R doit s’occuper de libérer périodiquement de façon automatique la mémoire qui n’est plus utilisée. Cette opération s’appelle « <a href="https://fr.wikipedia.org/wiki/Ramasse-miettes_(informatique)">récupération de mémoire</a> », en anglais <em>garbage collection</em> ou <em>gc</em>. Il s’agit d’une opération essentielle pour ne pas saturer la mémoire de l’ordinateur pendant une session R.</p>
<p>Tout comme l’allocation de mémoire, la récupération de mémoire prend un peu de temps à être réalisée. Il est donc pertinent de savoir si le récupérateur de mémoire (<em>garbage collector</em>), aussi appelé ramasse-miettes, a été lancé pendant l’exécution d’une expression. Cette opération, dont nous ne contrôlons pas le déclenchement, ralentit légèrement les exécutions.</p>
</div>
</div>
<div id="fonctions-rprof-et-summaryrprof" class="section level2">
<h2>Fonctions <code>Rprof</code> et <code>summaryRprof</code></h2>
<p>Les fonctions <code>system.time</code> et <code>mark</code> sont bien pratiques pour évaluer un temps global d’exécution. Cependant, elles ne nous aident pas à identifier les parties d’un programme R, typiquement le corps d’une fonction, qui sont les plus lentes. Pour arriver à identifier les instructions causant des lenteurs, il faut plutôt utiliser un outil telles que les fonctions <a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/Rprof.html"><code>Rprof</code></a> et <a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/summaryRprof.html"><code>summaryRprof</code></a>.</p>
<p>Pour utiliser ces fonctions, il faut ajouter la commande <code>Rprof()</code> avant le bout de code à minuter et ajouter <code>Rprof(NULL)</code> après le bout de code, comme dans cet exemple :</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">Rprof</span>(<span class="dt">interval =</span> <span class="fl">0.001</span>)</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="kw">compte_impair_boucle</span>(obs)</a>
<a class="sourceLine" id="cb27-3" title="3"><span class="kw">Rprof</span>(<span class="ot">NULL</span>)</a></code></pre></div>
<p>Un fichier a est créé dans notre répertoire de travail. Il se nomme par défaut <code>Rprof.out</code>, mais nous pouvons changer ce nom avec l’argument <code>filename</code> de la fonction <code>Rprof</code>. À chaque 0.001 seconde (argument <code>interval</code>), R a écrit dans ce fichier le nom de la fonction ou des fonctions dont un appel est en cours d’exécution. La fonction <code>Rprof</code> conserve donc une trace de la <a href="https://fr.wikipedia.org/wiki/Pile_d%27ex%C3%A9cution">pile d’exécution</a> (en anglais <em>call stack</em>) à intervalle de temps fixes.</p>
<p>Typiquement, nous n’allons pas voir directement le contenu de ce fichier. Nous en affichons plutôt un résumé avec la fonction <code>summaryRprof</code> comme suit :</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">summaryRprof</span>(<span class="st">&quot;Rprof.out&quot;</span>)</a></code></pre></div>
<pre><code>## $by.self
##                        self.time self.pct total.time total.pct
## &quot;compte_impair_boucle&quot;     0.095    52.49      0.181    100.00
## &quot;%%&quot;                       0.086    47.51      0.086     47.51
## 
## $by.total
##                        total.time total.pct self.time self.pct
## &quot;compte_impair_boucle&quot;      0.181    100.00     0.095    52.49
## &quot;%%&quot;                        0.086     47.51     0.086    47.51
## 
## $sample.interval
## [1] 0.001
## 
## $sampling.time
## [1] 0.181</code></pre>
<p>Dans cette sortie, les éléments <code>by.self</code> et <code>by.total</code> contiennent les mêmes valeurs, mais pas dans le même ordre (colonnes interchangées). Les colonnes <code>total.time</code> et <code>total.pct</code> réfèrent au temps total passé à l’exécution de l’appel à une fonction. Pour les colonnes <code>self.time</code> et <code>self.pct</code>, le temps d’exécution des appels de fonctions imbriqués dans l’appel de la fonction en question est retiré du temps total.</p>
<p>Dans l’exemple, la commande <code>compte_impair_boucle(x)</code> prend un total de 0.181 seconde à être évaluée. Exécuter un appel à la fonction <code>compte_impair_boucle</code> signifie exécuter le corps de la fonction avec les valeurs d’arguments fournis en entrée. De l’exécution du corps de la fonction <code>compte_impair_boucle</code>, seul l’appel à l’opérateur <code>%%</code> apparaît dans la sortie de <code>summaryRprof</code>. Les appels aux autres fonctions ou opérateurs sont ici tellement rapides qu’ils n’ont pas été détectés par <code>Rprof</code>. Le temps passé à évaluer les appels à l’opérateur <code>%%</code> est de 0.086 seconde. Ainsi, le <code>self.time</code> de <code>compte_impair_boucle</code> est 0.181 - 0.086 = 0.095 seconde.</p>
<p>Afin de mieux expliquer l’interprétation de la sortie de <code>summaryRprof</code>, voyons aussi un autre exemple qui produit une sortie un plus longue. Les arguments <code>memory.profiling</code> et <code>gc.profiling</code> de la fonction <code>Rprof</code> sont illustrés.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1"><span class="co"># Facteur généré aléatoirement pour l&#39;exemple</span></a>
<a class="sourceLine" id="cb30-2" title="2">facteur &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">size =</span> <span class="kw">length</span>(obs), <span class="dt">replace =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="co"># Profilage du temps d&#39;exécution et de la gestion de la mémoire </span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="co"># d&#39;un appel à aggregate avec les données simulées</span></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="kw">Rprof</span>(<span class="dt">interval =</span> <span class="fl">0.01</span>, <span class="dt">memory.profiling =</span> <span class="ot">TRUE</span>, <span class="dt">gc.profiling =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb30-7" title="7">res &lt;-<span class="st"> </span><span class="kw">aggregate</span>(<span class="dt">x =</span> obs, <span class="dt">by =</span> <span class="kw">list</span>(facteur), <span class="dt">FUN =</span> median)</a>
<a class="sourceLine" id="cb30-8" title="8"><span class="kw">Rprof</span>(<span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb30-9" title="9"></a>
<a class="sourceLine" id="cb30-10" title="10"><span class="co"># Résumé de la sortie de Rprof</span></a>
<a class="sourceLine" id="cb30-11" title="11"><span class="kw">summaryRprof</span>(<span class="st">&quot;Rprof.out&quot;</span>, <span class="dt">memory =</span> <span class="st">&quot;both&quot;</span>)</a></code></pre></div>
<pre><code>## $by.self
##                         self.time self.pct total.time total.pct mem.total
## &quot;[.data.frame&quot;               0.07    24.14       0.18     62.07      77.4
## &quot;&lt;GC&gt;&quot;                       0.06    20.69       0.06     20.69      15.3
## &quot;&lt;Anonymous&gt;&quot;                0.04    13.79       0.05     17.24       7.6
## &quot;anyDuplicated.default&quot;      0.03    10.34       0.03     10.34       8.0
## &quot;unique.default&quot;             0.02     6.90       0.07     24.14      23.6
## &quot;match&quot;                      0.01     3.45       0.07     24.14      27.5
## &quot;split.default&quot;              0.01     3.45       0.02      6.90      34.7
## &quot;as.character.factor&quot;        0.01     3.45       0.01      3.45       0.0
## &quot;complete.cases&quot;             0.01     3.45       0.01      3.45       3.9
## &quot;f&quot;                          0.01     3.45       0.01      3.45       0.0
## &quot;factor&quot;                     0.01     3.45       0.01      3.45      23.3
## &quot;is.na&quot;                      0.01     3.45       0.01      3.45       8.5
## 
## $by.total
##                         total.time total.pct mem.total self.time self.pct
## &quot;aggregate&quot;                   0.28     96.55     144.0      0.00     0.00
## &quot;aggregate.data.frame&quot;        0.28     96.55     144.0      0.00     0.00
## &quot;aggregate.default&quot;           0.28     96.55     144.0      0.00     0.00
## &quot;[.data.frame&quot;                0.18     62.07      77.4      0.07    24.14
## &quot;[&quot;                           0.18     62.07      77.4      0.00     0.00
## &quot;unique.default&quot;              0.07     24.14      23.6      0.02     6.90
## &quot;match&quot;                       0.07     24.14      27.5      0.01     3.45
## &quot;sort&quot;                        0.07     24.14      20.3      0.00     0.00
## &quot;&lt;GC&gt;&quot;                        0.06     20.69      15.3      0.06    20.69
## &quot;unique&quot;                      0.06     20.69      11.8      0.00     0.00
## &quot;&lt;Anonymous&gt;&quot;                 0.05     17.24       7.6      0.04    13.79
## &quot;do.call&quot;                     0.05     17.24       7.6      0.00     0.00
## &quot;FUN&quot;                         0.04     13.79      55.1      0.00     0.00
## &quot;lapply&quot;                      0.04     13.79      55.1      0.00     0.00
## &quot;anyDuplicated.default&quot;       0.03     10.34       8.0      0.03    10.34
## &quot;anyDuplicated&quot;               0.03     10.34       8.0      0.00     0.00
## &quot;split.default&quot;               0.02      6.90      34.7      0.01     3.45
## &quot;as.factor&quot;                   0.02      6.90      35.1      0.00     0.00
## &quot;sort.int&quot;                    0.02      6.90      20.3      0.00     0.00
## &quot;split&quot;                       0.02      6.90      34.7      0.00     0.00
## &quot;unname&quot;                      0.02      6.90      34.7      0.00     0.00
## &quot;as.character.factor&quot;         0.01      3.45       0.0      0.01     3.45
## &quot;complete.cases&quot;              0.01      3.45       3.9      0.01     3.45
## &quot;f&quot;                           0.01      3.45       0.0      0.01     3.45
## &quot;factor&quot;                      0.01      3.45      23.3      0.01     3.45
## &quot;is.na&quot;                       0.01      3.45       8.5      0.01     3.45
## &quot;.rs.callAs&quot;                  0.01      3.45       0.0      0.00     0.00
## &quot;as.character&quot;                0.01      3.45       0.0      0.00     0.00
## &quot;doTryCatch&quot;                  0.01      3.45       0.0      0.00     0.00
## &quot;mean&quot;                        0.01      3.45       8.5      0.00     0.00
## &quot;median.default&quot;              0.01      3.45       8.5      0.00     0.00
## &quot;Rprof&quot;                       0.01      3.45       0.0      0.00     0.00
## &quot;sort.default&quot;                0.01      3.45       8.5      0.00     0.00
## &quot;tryCatch&quot;                    0.01      3.45       0.0      0.00     0.00
## &quot;tryCatchList&quot;                0.01      3.45       0.0      0.00     0.00
## &quot;tryCatchOne&quot;                 0.01      3.45       0.0      0.00     0.00
## &quot;withCallingHandlers&quot;         0.01      3.45       0.0      0.00     0.00
## 
## $sample.interval
## [1] 0.01
## 
## $sampling.time
## [1] 0.29</code></pre>
<p>Dans cet exemple, les éléments <code>by.self</code> et <code>by.total</code> ne contiennent pas les mêmes lignes. Les fonctions dont les <code>self.time</code> sont nuls n’apparaissent pas dans l’élément <code>by.self</code>. Nous voyons aussi que les lignes sont ordonnées en ordre décroissant de <code>self.time</code> dans l’élément <code>by.self</code> et en ordre décroissant de <code>total.time</code> dans l’élément <code>by.total</code>.</p>
<p>La colonne <code>mem.total</code> a été ajoutée comparativement à la sortie obtenue dans l’exemple précédent. Elle indique la quantité de mémoire utilisée. Elle est présente en raison de l’argument <code>memory.profiling = TRUE</code>. L’argument <code>gc.profiling = TRUE</code> à quant à lui pour effet de rapporter les temps d’appel au récupréateur de mémoire, identifié par <code>"&lt;GC&gt;"</code>, si celui-ci a été lancé.</p>
<p>Nous constatons que le code de la méthode <code>aggregate.data.frame</code> fait appel à un grand nombre de fonctions. Nous n’analyserons pas cette sortie davantage ici. Mentionnons seulement que les méthodes de la fonction générique <code>aggregate</code> ne sont pas vraiment conçues pour être rapides.</p>
</div>
<div id="package-profvis" class="section level2">
<h2>Package <code>profvis</code></h2>
<p>Pour identifier encore plus facilement les lignes les plus lentes de notre code, nous pouvons utiliser le <a href="https://CRAN.R-project.org/package=profvis">package <code>profvis</code></a>. Ce package offre en fait une façon de visualiser le résultat produit par <code>Rprof</code>. Voici un exemple de son utilisation.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">library</span>(profvis)</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="kw">profvis</span>({</a>
<a class="sourceLine" id="cb32-3" title="3">  compte_impair_boucle &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb32-4" title="4">    k &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb32-5" title="5">    <span class="cf">for</span> (n <span class="cf">in</span> x) {</a>
<a class="sourceLine" id="cb32-6" title="6">      <span class="cf">if</span> (n <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span>){</a>
<a class="sourceLine" id="cb32-7" title="7">        k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb32-8" title="8">      } </a>
<a class="sourceLine" id="cb32-9" title="9">    }</a>
<a class="sourceLine" id="cb32-10" title="10">    k</a>
<a class="sourceLine" id="cb32-11" title="11">  }</a>
<a class="sourceLine" id="cb32-12" title="12">  <span class="kw">compte_impair_boucle</span>(obs)</a>
<a class="sourceLine" id="cb32-13" title="13">})</a></code></pre></div>
<p>Pour obtenir le détail du temps d’exécution par ligne du corps d’une de nos fonctions, il faut fournir, dans l’appel à la fonction <code>profvis</code>, le code définissant la fonction en plus de l’instruction appelant la fonction. Remarquez les accolades nécessaires lorsque l’expression à profiler s’étend sur plus d’une ligne. Le résultat obtenu est ouvert dans une fenêtre indépendante, dont voici une copie :</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-21"></span>
<img src="fig/profvis.png" alt="Fenêtre de profilage ouverte par l'exemple  d'appel à la fonction profvis précédent" width="100%" />
<p class="caption">
Figure 1: Fenêtre de profilage ouverte par l’exemple d’appel à la fonction profvis précédent
</p>
</div>
<p>RStudio intègre particulièrement bien la fenêtre affichant les résultats d’un appel à la fonction <code>profvis</code>. La figure précédente ne montre qu’un des deux onglets de cette fenêtre, soit l’onglet <code>Flame Graph</code>. La fonction <code>profvis</code> profile à la fois l’utilisation de la mémoire (colonne <code>Memory</code>) et du temps d’exécution (colonne <code>Time</code>).</p>
<p>Dans l’exemple, nous voyons encore clairement que ce sont les appels à l’opérateur <code>%%</code> qui prennent le plus de temps à être évalués dans le corps de la fonction <code>compte_impair_boucle</code>.</p>
<p>Le site web suivant documente l’utilisation du package profvis : <a href="http://rstudio.github.io/profvis/" class="uri">http://rstudio.github.io/profvis/</a>.</p>
</div>
</div>
<div id="stratégies-doptimisation-du-temps-dexécution" class="section level1">
<h1>Stratégies d’optimisation du temps d’exécution</h1>
<p>Il y a différentes stratégies utiles à connaître pour écrire du code R rapide. Voici une énumération de ces stratégies, qui sont présentées dans les sous-sections suivantes.</p>
<ol style="list-style-type: decimal">
<li>Utiliser des fonctions optimisées.</li>
<li>Faire seulement ce qui est nécessaire.</li>
<li>Exploiter les calculs matriciels et vectoriels.</li>
<li>Éviter les allocations de mémoire inutiles.</li>
<li>Faire du calcul en parallèle.</li>
<li>Reprogrammer en C ou C++ les bouts de code les plus lents.</li>
</ol>
<p>Pour illustrer ces astuces, nous allons souvent utiliser un exemple tiré de <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a>. Il s’agit des fonctions R ayant pour but d’estimer la fonction de densité d’une variable aléatoire par la méthode du noyau à partir d’observations de la variable aléatoire. De l’information sur cette méthode, appelée en anglais <em>Kernel density estimation</em>, peut être trouvée sur la page Wikipédia suivante : <a href="https://fr.wikipedia.org/wiki/Estimation_par_noyau" class="uri">https://fr.wikipedia.org/wiki/Estimation_par_noyau</a>.</p>
<p>Il existe en fait déjà une fonction dans le package <code>stats</code> pour faire de l’estimation de densité par noyau. Il s’agit de la <a href="https://stat.ethz.ch/R-manual/R-patched/library/stats/html/density.html">fonction <code>density</code></a>. Voici un exemple de ce qu’il est possible de réaliser avec cette fonction.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" title="1">dens &lt;-<span class="st"> </span><span class="kw">density</span>(<span class="dt">x =</span> faithful<span class="op">$</span>eruptions)  <span class="co"># faithful provient du package datasets</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="kw">hist</span>(</a>
<a class="sourceLine" id="cb33-3" title="3">  <span class="dt">x =</span> faithful<span class="op">$</span>eruptions, </a>
<a class="sourceLine" id="cb33-4" title="4">  <span class="dt">freq =</span> <span class="ot">FALSE</span>, </a>
<a class="sourceLine" id="cb33-5" title="5">  <span class="dt">ylab =</span> <span class="st">&quot;densité&quot;</span>,</a>
<a class="sourceLine" id="cb33-6" title="6">  <span class="dt">main =</span> <span class="st">&quot;Densité empirique des durées des éruptions du geyser Old Faithful&quot;</span>,</a>
<a class="sourceLine" id="cb33-7" title="7">  <span class="dt">cex.main =</span> <span class="fl">0.9</span></a>
<a class="sourceLine" id="cb33-8" title="8">)</a>
<a class="sourceLine" id="cb33-9" title="9"><span class="kw">lines</span>(dens)</a></code></pre></div>
<p><img src="/amelioration_code/optim_temps_r_2020_files/figure-html/unnamed-chunk-22-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Un histogramme est aussi une méthode d’estimation de densité. Ici, nous avons superposé une courbe de densité estimée par la méthode du noyau (aussi appelée densité Kernel) à un histogramme.</p>
<p>Nous allons écrire une version moins puissante de la fonction <code>density</code>. L’estimation de densité par noyau au point <span class="math inline">\(x\)</span> se fait par la formule suivante :</p>

<p><span class="math inline">\(\hat{f}(x) = \frac{1}{nh} \sum_{i = 1}^n K \left( \frac{x - x_i}{h} \right)\)</span></p>

<p>où <span class="math inline">\(x_i\)</span> pour <span class="math inline">\(i=1, 2, \ldots, n\)</span> sont les observations, <span class="math inline">\(K\)</span> est une fonction noyau (en anglais <em>kernel</em>) à définir et <span class="math inline">\(h\)</span> est un paramètre de lissage (parfois appelée fenêtre). Plus la valeur de <span class="math inline">\(h\)</span> est grande, plus la courbe obtenue est lisse.</p>
<p>La fonction <code>density</code> permet l’utilisation de plusieurs fonctions noyau via l’argument <code>kernel</code>. Nous allons plutôt nous restreindre au noyau gaussien, qui est en fait la fonction de densité d’une distribution normale standard. Nous allons donc utiliser la fonction <code>dnorm</code> pour évaluer la fonction <span class="math inline">\(K\)</span> dans la formule ci-dessus.</p>
<p>Voici la première fonction proposée.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" title="1"><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="co">#&#39; @description Version 1 : utilisation de 2 boucles imbriquées</span></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="co">#&#39; @param x vecteur numérique contenant les observations</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="co">#&#39; @param xpts vecteur numérique contenant les points en lesquels l&#39;estimation de la </span></a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">#&#39;             densité doit être effectuée</span></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">#&#39; @param h nombre réel &gt; 0 : la valeur du paramètre de lissage</span></a>
<a class="sourceLine" id="cb34-7" title="7"><span class="co">#&#39; @return vecteur numérique contenant la densité estimée en tous les points de xpts</span></a>
<a class="sourceLine" id="cb34-8" title="8">ksmooth_double_loop &lt;-<span class="st"> </span><span class="cf">function</span>(x, xpts, h) </a>
<a class="sourceLine" id="cb34-9" title="9">{</a>
<a class="sourceLine" id="cb34-10" title="10">  dens &lt;-<span class="st"> </span><span class="kw">double</span>(<span class="kw">length</span>(xpts))</a>
<a class="sourceLine" id="cb34-11" title="11">  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb34-12" title="12">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(xpts)) {</a>
<a class="sourceLine" id="cb34-13" title="13">    ksum &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb34-14" title="14">    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {</a>
<a class="sourceLine" id="cb34-15" title="15">      d &lt;-<span class="st"> </span>xpts[i] <span class="op">-</span><span class="st"> </span>x[j]</a>
<a class="sourceLine" id="cb34-16" title="16">      ksum &lt;-<span class="st"> </span>ksum <span class="op">+</span><span class="st"> </span><span class="kw">dnorm</span>(d <span class="op">/</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb34-17" title="17">    }</a>
<a class="sourceLine" id="cb34-18" title="18">    dens[i] &lt;-<span class="st"> </span>ksum <span class="op">/</span><span class="st"> </span>(n <span class="op">*</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb34-19" title="19">  }</a>
<a class="sourceLine" id="cb34-20" title="20">  dens</a>
<a class="sourceLine" id="cb34-21" title="21">}</a></code></pre></div>
<p>Dans la fonction <code>ksmooth_double_loop</code>, le premier argument, nommé <code>x</code>, n’est pas équivalent au <span class="math inline">\(x\)</span> de la formule. Le <span class="math inline">\(x\)</span> de la formule représente un point en lequel nous souhaitons faire l’estimation. Son équivalent dans la fonction <code>ksmooth_double_loop</code> est donc un élément du vecteur <code>xpts</code>. Ce sont les <span class="math inline">\(x_i\)</span> de la formule que nous retrouvons dans le vecteur <code>x</code>. Dans la boucle, ce vecteur <code>x</code> est parcouru en utilisant l’indice <code>j</code>. Alors, en fait, <code>x[j]</code> dans le corps de la fonction représente un <span class="math inline">\(x_i\)</span> dans la formule. Le code aurait pu coller davantage à la notation dans la formule pour être encore plus clair, mais j’ai choisi de le conserver tel qu’il a été proposé dans <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a>. Tout ce que j’ai changé ici par rapport à cette référence est le nom de la fonction. J’ai renommé <code>ksmooth_double_loop</code> la fonction que <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a> ont nommé <code>ksmooth1</code>.</p>
<p>Notons que nous pouvons considérer ici que la fonction <code>ksmooth_double_loop</code> a d’abord été testée. Nous supposons donc qu’elle retourne un résultat valide. Voici d’ailleurs ce qu’elle retourne si elle reçoit en entrée dix mille observations générées aléatoirement selon une loi normale standard et que nous lui demandons d’effectuer une estimation de densité en 17 points entre -4 et 4 (la séquence des nombres entre -4 et 4 inclusivement, par bonds de 0.5).</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" title="1"><span class="co"># Simulation des observations</span></a>
<a class="sourceLine" id="cb35-2" title="2">x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10000</span>)</a>
<a class="sourceLine" id="cb35-3" title="3"><span class="co"># Points pour lesquels nous souhaitons estimer la densité</span></a>
<a class="sourceLine" id="cb35-4" title="4">xpts &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">-4</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">length.out =</span> <span class="dv">17</span>)</a>
<a class="sourceLine" id="cb35-5" title="5"><span class="co"># Résultat obtenu</span></a>
<a class="sourceLine" id="cb35-6" title="6">densite_kdl &lt;-<span class="st"> </span><span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb35-7" title="7"><span class="co"># Graphique</span></a>
<a class="sourceLine" id="cb35-8" title="8"><span class="kw">hist</span>(</a>
<a class="sourceLine" id="cb35-9" title="9">  <span class="dt">x =</span> x, </a>
<a class="sourceLine" id="cb35-10" title="10">  <span class="dt">freq =</span> <span class="ot">FALSE</span>, </a>
<a class="sourceLine" id="cb35-11" title="11">  <span class="dt">ylab =</span> <span class="st">&quot;densité&quot;</span>,</a>
<a class="sourceLine" id="cb35-12" title="12">  <span class="dt">main =</span> <span class="st">&quot;Densité empirique d&#39;un échantillon aléatoire tiré d&#39;une distribution N(0, 1)&quot;</span>,</a>
<a class="sourceLine" id="cb35-13" title="13">  <span class="dt">cex.main =</span> <span class="fl">0.9</span></a>
<a class="sourceLine" id="cb35-14" title="14">)</a>
<a class="sourceLine" id="cb35-15" title="15"><span class="kw">lines</span>(<span class="dt">x =</span> xpts, <span class="dt">y =</span> densite_kdl)</a></code></pre></div>
<p><img src="/amelioration_code/optim_temps_r_2020_files/figure-html/unnamed-chunk-25-1.png" width="80%" style="display: block; margin: auto;" /></p>
<div id="astuce-1-utiliser-des-fonctions-optimisées" class="section level2">
<h2>Astuce 1 : Utiliser des fonctions optimisées</h2>
<p>Lorsque nous devons effectuer une tâche pour laquelle une fonction optimisée en temps de calcul existe déjà, il est préférable d’utiliser cette fonction. R est un logiciel libre. Le partage de code fait partie de la philosophie première du logiciel. Et cette réutilisation peut nous faire économiser beaucoup de temps.</p>
<p>Par exemple, est-ce que la fonction <code>density</code>, provenant du package <code>stats</code>, est plus rapide que la fonction <code>ksmooth_double_loop</code>?</p>
<p>Premièrement, convainquons-nous que les deux fonctions peuvent effectuer le même calcul. Réutilisons les vecteurs <code>x</code> et <code>xpts</code> créés ci-dessus. La commande suivante :</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" title="1">densite_kdl &lt;-<span class="st"> </span><span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a></code></pre></div>
<p>lance pratiquement le même calcul que cette commande :</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" title="1">densite_d &lt;-<span class="st"> </span><span class="kw">density</span>(</a>
<a class="sourceLine" id="cb37-2" title="2">  <span class="dt">x =</span> x,</a>
<a class="sourceLine" id="cb37-3" title="3">  <span class="dt">bw =</span> <span class="dv">1</span>, <span class="dt">kernel =</span> <span class="st">&quot;gaussian&quot;</span>,</a>
<a class="sourceLine" id="cb37-4" title="4">  <span class="dt">from =</span> <span class="dv">-4</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">n =</span> <span class="dv">17</span></a>
<a class="sourceLine" id="cb37-5" title="5">)</a></code></pre></div>
<p>Rappelons que <code>xpts</code> avait été défini comme suit :</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" title="1">xpts &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">-4</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">length.out =</span> <span class="dv">17</span>)</a></code></pre></div>
<p>d’où le choix des valeurs fournies aux arguments <code>from</code>, <code>to</code> et <code>n</code> de <code>density</code>.</p>
<p>Comparons maintenant les valeurs obtenues.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">all.equal</span>(densite_kdl, densite_d<span class="op">$</span>y)</a></code></pre></div>
<pre><code>## [1] &quot;Mean relative difference: 0.0009604423&quot;</code></pre>
<p>Il y a de très petites différences entre les valeurs, parce que le paramètre de lissage <code>h</code> de <code>ksmooth_double_loop</code> n’est pas tout à fait définit comme le paramètre <code>bw</code> de la fonction <code>density</code>. Cependant, ces différences sont tellement petites que nous pouvons tout de même considérer que les deux fonctions effectuent le même calcul.</p>
<p>Comparons les temps d’exécution des deux fonctions.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" title="1">ex_astuce_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb41-2" title="2">  <span class="dt">ksmooth_double_loop =</span> <span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb41-3" title="3">  <span class="dt">density =</span> <span class="kw">density</span>(<span class="dt">x =</span> x, <span class="dt">bw =</span> <span class="dv">1</span>, <span class="dt">kernel =</span> <span class="st">&quot;gaussian&quot;</span>, <span class="dt">from =</span> <span class="dv">-4</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">n =</span> <span class="dv">17</span>), </a>
<a class="sourceLine" id="cb41-4" title="4">  <span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="dt">check =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb41-5" title="5">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" title="1"><span class="kw">print_bench_mark</span>(ex_astuce_<span class="dv">1</span>)</a></code></pre></div>
<pre><code>##            expression n_itr      min   median mem_alloc n_gc
## 1 ksmooth_double_loop    10 222.8600 244.6188      184B   58
## 2             density   599   0.4581   0.8143     315KB    4</code></pre>
<p>La fonction <code>density</code> retourne presque instantanément le résultat, alors que la fonction <code>ksmooth_double_loop</code> doit rouler pendant plusieurs secondes pour effectuer une estimation en 17 points, à partir de 10000 observations.</p>
<p>Le coeur du calcul de la fonction <code>density</code> est effectué par du code en langage C. C’est pour cette raison qu’elle est à ce point plus rapide que la fonction <code>ksmooth_double_loop</code>. Nous allons y revenir à l’astuce 6.</p>
</div>
<div id="astuce-2-faire-seulement-ce-qui-est-nécessaire" class="section level2">
<h2>Astuce 2 : Faire seulement ce qui est nécessaire</h2>
<p>L’idée derrière cette astuce est simplement de ne pas alourdir un code d’évaluations inutiles.</p>
<p>Par exemple, si nous voulons calculer la somme des valeurs dans chacune des colonnes d’une matrice, la fonction <code>colSums</code> est plus rapide que la fonction <code>apply</code>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" title="1">mat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">100</span> <span class="op">*</span><span class="st"> </span><span class="dv">1000</span>), <span class="dt">nrow =</span> <span class="dv">100</span>, <span class="dt">ncol =</span> <span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb45-2" title="2">ex_astuce_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb45-3" title="3">  <span class="kw">colSums</span>(<span class="dt">x =</span> mat), </a>
<a class="sourceLine" id="cb45-4" title="4">  <span class="kw">apply</span>(<span class="dt">X =</span> mat, <span class="dt">MARGIN =</span> <span class="dv">2</span>, <span class="dt">FUN =</span> sum),</a>
<a class="sourceLine" id="cb45-5" title="5">  <span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;us&quot;</span></a>
<a class="sourceLine" id="cb45-6" title="6">)</a>
<a class="sourceLine" id="cb45-7" title="7"><span class="kw">print_bench_mark</span>(ex_astuce_<span class="dv">2</span>)</a></code></pre></div>
<pre><code>##                              expression n_itr    min median mem_alloc n_gc
## 1                      colSums(x = mat)  5603   62.7   90.5    7.86KB    1
## 2 apply(X = mat, MARGIN = 2, FUN = sum)   179 1413.4 2224.8    2.02MB    9</code></pre>
<p>Ce résultat s’explique par le fait que la fonction <code>colSums</code> est spécialisée dans la tâche que nous cherchions à effectuer. Son code est simplifié, par rapport au code de <code>apply</code> qui peut appliquer n’importe quelle fonction sur n’importe quelle dimension d’un array. Nous pourrions aussi dire que la fonction <code>colSums</code> est une fonction optimisée.</p>
<p>Remarquons que la fonction <code>apply</code> utilise ici beaucoup plus de mémoire que la fonction <code>colSums</code>.</p>
<!-- Retiré, car pas vraiment de gain en temps.

C'est cette astuce, de faire seulement ce qui est nécessaire, qui pousse certains programmeurs R à ne pas utiliser la fonction `return` pour retourner la sortie de leurs fonctions. L'appel à la fonction `return` amène une évaluation de plus à effectuer, sans être nécessaire. Pour faire un test, ajoutons un appel à la fonction `return` à la fin de la fonction `compte_impair_vectoriel`.


```r
compte_impair_vectoriel_return <- function(x) {
  return(sum(x %% 2 == 1))
}
```

Maintenant, comparons les temps d'exécution des fonctions `compte_impair_vectoriel` et `compte_impair_vectoriel_return`.


```r
ex_return <- mark(
  sans_return = compte_impair_vectoriel(x),
  avec_return = compte_impair_vectoriel_return(x),
  min_iterations = 100,
  time_unit = "us"
)
print_bench_mark(ex_return)
```

La fonction `compte_impair_vectoriel_return` est effectivement légèrement plus lente que la fonction `compte_impair_vectoriel`. Mais la différence entre les temps d'exécution médians des deux fonctions est à peine de l'ordre de quelques microsecondes. Alors d'autres programmeurs R préfèrent utiliser `return`, même s'il ralentit très légèrement les fonctions, dans le but d'avoir un code le plus clair possible.

-->
</div>
<div id="astuce-3-exploiter-les-calculs-matriciels-et-vectoriels" class="section level2">
<h2>Astuce 3 : Exploiter les calculs matriciels et vectoriels</h2>
<p>Nous avons déjà vu qu’en effectuant des calculs matriciels et vectoriels en R, comme avec la fonction <code>compte_impair_vectoriel</code>, nous arrivons à faire un calcul beaucoup plus rapidement qu’avec une boucle, comme avec la fonction <code>compte_impair_boucle</code>. Le calcul matriciel ou vectoriel en R est optimisé pour être très rapide. En fait, ces types de calculs font intervenir des boucles, mais programmées et compilées dans un langage informatique de plus bas niveau (et donc plus rapide) que R tel que le langage C ou Fortran.</p>
<p>Pour illustrer une fois de plus cette astuce, étudions la performance d’une autre fonction d’estimation de densité par noyau gaussien tirée de <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a> : la fonction <code>ksmooth2</code>, ici renommée <code>ksmooth_outer</code>. Le corps de cette fonction ne contient aucune boucle. Il fait plutôt du calcul vectoriel en utilisant, notamment, la fonction <code>outer</code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" title="1"><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="co">#&#39; @description Version 2 : utilisation de calcul vectoriel seulement</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="co">#&#39; @inherit ksmooth_double_loop params return</span></a>
<a class="sourceLine" id="cb47-4" title="4">ksmooth_outer &lt;-<span class="st"> </span><span class="cf">function</span>(x, xpts, h) </a>
<a class="sourceLine" id="cb47-5" title="5">{</a>
<a class="sourceLine" id="cb47-6" title="6">  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb47-7" title="7">  D &lt;-<span class="st"> </span><span class="kw">outer</span>(x, xpts, <span class="st">&quot;-&quot;</span>)</a>
<a class="sourceLine" id="cb47-8" title="8">  K &lt;-<span class="st"> </span><span class="kw">dnorm</span>(D <span class="op">/</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb47-9" title="9">  dens &lt;-<span class="st"> </span><span class="kw">colSums</span>(K) <span class="op">/</span><span class="st"> </span>(h <span class="op">*</span><span class="st"> </span>n)</a>
<a class="sourceLine" id="cb47-10" title="10">}</a></code></pre></div>
<p>Nous aurions aussi pu coder la fonction <code>ksmooth</code> ainsi.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" title="1"><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="co">#&#39; @description Version 3 : utilisation d&#39;une boucle et d&#39;un calcul vectoriel</span></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="co">#&#39; @inherit ksmooth_double_loop params return</span></a>
<a class="sourceLine" id="cb48-4" title="4">ksmooth_loop &lt;-<span class="st"> </span><span class="cf">function</span>(x, xpts, h) </a>
<a class="sourceLine" id="cb48-5" title="5">{</a>
<a class="sourceLine" id="cb48-6" title="6">  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb48-7" title="7">  dens &lt;-<span class="st"> </span><span class="kw">double</span>(<span class="kw">length</span>(xpts))</a>
<a class="sourceLine" id="cb48-8" title="8">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(xpts)) {</a>
<a class="sourceLine" id="cb48-9" title="9">    dens[i] &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">dnorm</span>((xpts[i] <span class="op">-</span><span class="st"> </span>x)<span class="op">/</span>h)) <span class="op">/</span><span class="st"> </span>(n <span class="op">*</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb48-10" title="10">  }</a>
<a class="sourceLine" id="cb48-11" title="11">  dens</a>
<a class="sourceLine" id="cb48-12" title="12">}</a></code></pre></div>
<p>Cette version remplace la deuxième boucle par un calcul vectoriel.</p>
<p>Nous aurions même pu procéder comme suit.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" title="1"><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="co">#&#39; @description Version 4 : utilisation d&#39;une fonction de la</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co">#&#39;              famille des apply et d&#39;un calcul vectoriel</span></a>
<a class="sourceLine" id="cb49-4" title="4"><span class="co">#&#39; @inherit ksmooth_double_loop params return</span></a>
<a class="sourceLine" id="cb49-5" title="5">ksmooth_apply &lt;-<span class="st"> </span><span class="cf">function</span>(x, xpts, h) </a>
<a class="sourceLine" id="cb49-6" title="6">{</a>
<a class="sourceLine" id="cb49-7" title="7">  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb49-8" title="8">  <span class="kw">sapply</span>(</a>
<a class="sourceLine" id="cb49-9" title="9">    <span class="dt">X =</span> xpts,</a>
<a class="sourceLine" id="cb49-10" title="10">    <span class="dt">FUN =</span> <span class="cf">function</span>(xpts_i) {</a>
<a class="sourceLine" id="cb49-11" title="11">      <span class="kw">sum</span>(<span class="kw">dnorm</span>((xpts_i <span class="op">-</span><span class="st"> </span>x) <span class="op">/</span><span class="st"> </span>h)) <span class="op">/</span><span class="st"> </span>(n <span class="op">*</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb49-12" title="12">    }</a>
<a class="sourceLine" id="cb49-13" title="13">  )</a>
<a class="sourceLine" id="cb49-14" title="14">}</a></code></pre></div>
<p>Cette version remplace la seule boucle restante par l’utilisation d’une fonction de la famille des <code>apply</code>.</p>
<p>Ces trois versions effectuent bien le même calcul que <code>ksmooth_double_loop</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" title="1">densite_kdl &lt;-<span class="st"> </span><span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb50-2" title="2">densite_ko &lt;-<span class="st"> </span><span class="kw">ksmooth_outer</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb50-3" title="3">densite_kl &lt;-<span class="st"> </span><span class="kw">ksmooth_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb50-4" title="4">densite_ka &lt;-<span class="st"> </span><span class="kw">ksmooth_apply</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb50-5" title="5"></a>
<a class="sourceLine" id="cb50-6" title="6"><span class="kw">all.equal</span>(densite_kdl, densite_ko)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">all.equal</span>(densite_kdl, densite_kl)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">all.equal</span>(densite_kdl, densite_ka)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Comparons maintenant les temps d’exécution des quatre versions de <code>ksmooth</code> écrites jusqu’à maintenant.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" title="1">ex_astuce_<span class="dv">3</span> &lt;-<span class="st"> </span><span class="kw">mark</span>(<span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;ms&quot;</span>,</a>
<a class="sourceLine" id="cb56-2" title="2">               <span class="dt">v1_double_boucle =</span> <span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>), </a>
<a class="sourceLine" id="cb56-3" title="3">  <span class="dt">v2_calcul_vectoriel_seulement =</span> <span class="kw">ksmooth_outer</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb56-4" title="4">  <span class="dt">v3_boucle_et_calcul_vectoriel =</span> <span class="kw">ksmooth_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb56-5" title="5">   <span class="dt">v4_apply_et_calcul_vectoriel =</span> <span class="kw">ksmooth_apply</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb56-6" title="6">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">print_bench_mark</span>(ex_astuce_<span class="dv">3</span>)</a></code></pre></div>
<pre><code>##                      expression n_itr      min   median mem_alloc n_gc
## 1              v1_double_boucle    10 190.5919 245.5691      184B   25
## 2 v2_calcul_vectoriel_seulement    26  13.3698  18.6855    6.51MB    5
## 3 v3_boucle_et_calcul_vectoriel    32  12.5173  15.8681     2.6MB    5
## 4  v4_apply_et_calcul_vectoriel    31  12.7583  15.5311    2.63MB    2</code></pre>
<p>Nous constatons que les deux dernières versions sont encore plus rapides que la version 2 utilisant seulement du calcul vectoriel!</p>
<p>Ce qu’il faut retenir de ces exemples est ceci :</p>
<ul>
<li><p><strong>Le code le plus rapide n’est pas toujours celui que nous croyons</strong>. Il est parfois difficile de prédire quel bout de code sera le plus rapide. Ici, nous aurions pu croire que le calcul totalement vectoriel (<code>ksmooth_outer</code>) serait plus rapide qu’une boucle jumelée à un calcul vectoriel (<code>ksmooth_loop</code>). Pourtant, <code>ksmooth_loop</code> est légèrement plus rapide que <code>ksmooth_outer</code>. Il est donc toujours recommandé, lors de l’optimisation du temps d’exécution d’une fonction, d’essayer les différentes solutions possibles et de mesurer leurs temps d’exécution.</p></li>
<li><p><strong>Les fonctions de la famille des <code>apply</code> ne sont pas nécessairement plus rapides qu’une boucle</strong>. Ces fonctions cachent littéralement des boucles et ne représentent pas une sorte de calcul vectoriel. Leur utilisation est recommandée principalement parce qu’elles mènent à du code plus court et plus clair selon plusieurs programmeurs R, pas à du code nécessairement plus rapide.</p></li>
</ul>
<div id="remarque-concernant-lutilisation-de-la-mémoire" class="section level4">
<h4>Remarque concernant l’utilisation de la mémoire</h4>

<p>La fonction <code>ksmooth_outer</code> est environ 13 fois plus rapide que la fonction <code>ksmooth_double_loop</code>. Cependant, elle utilise beaucoup plus de mémoire ( 6.51MB versus 184B). Une matrice de dimension <code>length(x)</code> par <code>length(xpts)</code> est créée par la fonction. R impose une limite sur la taille des objets créés (pour plus de détails voir la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/Memory-limits.html">fiche d’aide <code>help("Memory-limits")</code></a>). Ainsi, la fonction <code>ksmooth_outer</code> retourne une erreur sur mon ordinateur si je lui donne en entrée des arguments <code>x</code> et <code>xpts</code> trop grands, par exemple :</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" title="1">x_test &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000000</span>)</a>
<a class="sourceLine" id="cb60-2" title="2">xpts_test &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">-4</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">length.out =</span> <span class="dv">1000000</span>)</a>
<a class="sourceLine" id="cb60-3" title="3">test_memoire &lt;-<span class="st"> </span><span class="kw">ksmooth_outer</span>(<span class="dt">x =</span> x_test, <span class="dt">xpts =</span> xpts_test, <span class="dt">h =</span> <span class="dv">1</span>)</a></code></pre></div>
<pre><code>## Error: cannot allocate vector of size 7450.6 Gb</code></pre>
<p>alors que la fonction <code>ksmooth_double_loop</code> est capable de traiter ces vecteurs.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" title="1"><span class="co"># Attention : ne pas rouler, long à exécuter</span></a>
<a class="sourceLine" id="cb62-2" title="2">test_memoire &lt;-<span class="st"> </span><span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x_test, <span class="dt">xpts =</span> xpts_test, <span class="dt">h =</span> <span class="dv">1</span>)</a></code></pre></div>
<p>C’est un bon exemple de compromis à gérer entre le temps d’exécution et la quantité de mémoire utilisée pour faire des calculs. Un programme peut être très rapide, mais créer un objet potentiellement de taille trop grande pour être stocké en mémoire. Étant donné que notre priorité est un code fonctionnel, il faut s’assurer de ne pas aller au-delà des limites de la mémoire de notre ordinateur. Alors, dans l’optimisation du temps d’exécution, il ne faut pas oublier de garder le contrôle sur la taille des objets créés par notre programme.</p>
</div>
</div>
<div id="astuce-4-éviter-les-allocations-de-mémoire-inutiles" class="section level2">
<h2>Astuce 4 : Éviter les allocations de mémoire inutiles</h2>
<p>Allouer de l’espace dans la mémoire d’un ordinateur est une opération coûteuse en temps. Deux opérations plutôt anodines sont à éviter dans une boucle R, car elles provoquent une ou des allocations en mémoire à chaque itération et ralentissent donc beaucoup la boucle. Il s’agit de :</p>
<ol style="list-style-type: decimal">
<li>l’utilisation d’un objet de dimension croissante,</li>
<li>l’assignation de valeur(s) à un ou des éléments d’un data frame.</li>
</ol>
<div id="objets-de-dimension-croissante" class="section level3">
<h3>Objets de dimension croissante</h3>
<p>Un objet de dimension croissante est, par exemple, une matrice à laquelle nous ajoutons, à chaque itération d’une boucle, une ligne avec <code>rbind</code> ou une colonne avec <code>cbind</code>, comme le fait l’instruction suivante :</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb63-1" title="1">matrice &lt;-<span class="st"> </span><span class="kw">rbind</span>(matrice, nouvelle_ligne)</a></code></pre></div>
<p>Avec un vecteur, une instruction similaire ferait plutôt appel à la fonction <code>c</code> ou <code>append</code> comme suit :</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" title="1">vecteur &lt;-<span class="st"> </span><span class="kw">c</span>(vecteur, nouvel_element)</a></code></pre></div>
<p>Le problème avec ces assignations est qu’elles modifient la dimension d’un objet. L’objet ne requiert donc plus la même quantité d’espace mémoire. Il ne serait pas une bonne idée de simplement utiliser les cases mémoires adjacentes pour agrandir l’objet, car ces cases mémoires sont potentiellement utilisées pour stocker d’autres objets R ou n’importe quelle valeur nécessaire à un processus en cours d’exécution sur l’ordinateur. L’ordinateur doit plutôt complètement déplacer l’objet dans de nouvelles cases mémoire qu’il sait être inutilisées afin de ne pas entrer en conflit avec quoi que ce soit. Ainsi, avec les commandes précédentes, nous avons peut-être l’impression de modifier le contenu de certaines cases mémoire alors qu’en réalité nous provoquons une nouvelle allocation de mémoire.</p>
<p><strong>Exemple</strong> :</p>
<p>Simulons une expérience aléatoire dans laquelle nous lançons un dé et additionnons les valeurs obtenues. L’expérience s’arrête lorsqu’une certaine somme cumulative des résultats a été atteinte.</p>
<p>La première fonction que nous allons créer pour simuler cette expérience va utiliser un objet de dimension croissante pour garder une trace des résultats.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb65-1" title="1"><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></a>
<a class="sourceLine" id="cb65-2" title="2"><span class="co">#&#39; @description Version utilisant un vecteur de taille croissante pour stocker les résultats</span></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="co">#&#39; @param somme_visee somme cumulative de valeurs obtenues à atteindre (par défaut 50000)</span></a>
<a class="sourceLine" id="cb65-4" title="4"><span class="co">#&#39; @return vecteur des résultats de tous les lancers de dé</span></a>
<a class="sourceLine" id="cb65-5" title="5">somme_de_vecteur_croissant &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">somme_visee =</span> <span class="dv">50000</span>){</a>
<a class="sourceLine" id="cb65-6" title="6">  somme &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb65-7" title="7">  resultats &lt;-<span class="st"> </span><span class="kw">integer</span>(<span class="dt">length =</span> <span class="dv">0</span>)  <span class="co"># ou resultats &lt;- NULL</span></a>
<a class="sourceLine" id="cb65-8" title="8">  <span class="cf">while</span>(somme <span class="op">&lt;</span><span class="st"> </span>somme_visee) {</a>
<a class="sourceLine" id="cb65-9" title="9">    tirage &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">size =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb65-10" title="10">    somme &lt;-<span class="st"> </span>somme <span class="op">+</span><span class="st"> </span>tirage</a>
<a class="sourceLine" id="cb65-11" title="11">    resultats &lt;-<span class="st"> </span><span class="kw">c</span>(resultats, tirage)</a>
<a class="sourceLine" id="cb65-12" title="12">  }</a>
<a class="sourceLine" id="cb65-13" title="13">  resultats</a>
<a class="sourceLine" id="cb65-14" title="14">}</a></code></pre></div>
<p>La deuxième fonction que nous allons créer pour simuler cette expérience va plutôt utiliser un grand objet de taille fixe pour stocker les résultats.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" title="1"><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></a>
<a class="sourceLine" id="cb66-2" title="2"><span class="co">#&#39; @description Version utilisant un vecteur de taille fixe pour stocker les résultats</span></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="co">#&#39; @inherit somme_de_vecteur_croissant params return</span></a>
<a class="sourceLine" id="cb66-4" title="4">somme_de_vecteur_fixe &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">somme_visee =</span> <span class="dv">50000</span>){</a>
<a class="sourceLine" id="cb66-5" title="5">  somme &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb66-6" title="6">  resultats &lt;-<span class="st"> </span><span class="kw">integer</span>(somme_visee)</a>
<a class="sourceLine" id="cb66-7" title="7">  i &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb66-8" title="8">  <span class="cf">while</span>(somme <span class="op">&lt;</span><span class="st"> </span>somme_visee) {</a>
<a class="sourceLine" id="cb66-9" title="9">    tirage &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">size =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb66-10" title="10">    somme &lt;-<span class="st"> </span>somme <span class="op">+</span><span class="st"> </span>tirage</a>
<a class="sourceLine" id="cb66-11" title="11">    i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb66-12" title="12">    resultats[i] &lt;-<span class="st"> </span>tirage</a>
<a class="sourceLine" id="cb66-13" title="13">  }</a>
<a class="sourceLine" id="cb66-14" title="14">  resultats[<span class="dv">1</span><span class="op">:</span>i]</a>
<a class="sourceLine" id="cb66-15" title="15">}</a></code></pre></div>
<p>Nous ne savons pas d’avance combien de lancers de dé devront être effectués pour atteindre une somme de <code>somme_visee</code>, mais nous savons que ce sera au maximum <code>somme_visee</code> lancers, puisque le plus petit résultat du lancer d’un dé est 1. Ainsi, nous créons d’abord un très grand vecteur, de longueur <code>somme_visee</code>, et nous allons modifier les éléments de ce vecteur à chaque itération de la boucle (une itération = un lancer de dé). Nous modifions d’abord le premier élément puis le deuxième et ainsi de suite, grâce à l’indicateur de position <code>i</code> que nous incrémentons de 1 à chaque itération. À la fin, nous retournons seulement les éléments du vecteur de résultat qui ont été modifiés.</p>
<p>Comparons les temps d’exécution des deux fonctions pour l’atteinte d’une somme de 50000.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb67-1" title="1">ex_dim_crois &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb67-2" title="2">  <span class="kw">somme_de_vecteur_croissant</span>(), </a>
<a class="sourceLine" id="cb67-3" title="3">  <span class="kw">somme_de_vecteur_fixe</span>(),</a>
<a class="sourceLine" id="cb67-4" title="4">  <span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="dt">check =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb67-5" title="5">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" title="1"><span class="kw">print_bench_mark</span>(ex_dim_crois)</a></code></pre></div>
<pre><code>##                     expression n_itr      min    median mem_alloc n_gc
## 1 somme_de_vecteur_croissant()    10 249.4764 287.99250     418MB  147
## 2      somme_de_vecteur_fixe()    10  57.6599  63.91805      35MB    8</code></pre>
<p>Nous constatons donc qu’en termes de temps de calcul, et même en termes de quantité de mémoire utilisée, il est ici préférable de créer un très grand objet, de le remplir, puis de mettre de côté les éléments inutilisés que de faire croître la taille d’un objet. C’est de la préallocation de mémoire. Par contre, encore là, il y a une limite à la grandeur de l’objet qui peut être créé.</p>
</div>
<div id="modification-déléments-dans-un-data-frame" class="section level3">
<h3>Modification d’éléments dans un data frame</h3>
<p>Lorsque nous modifions les éléments d’un objet R dans une boucle, comme nous avons fait dans la fonction <code>somme_de_vecteur_fixe</code> par l’instruction suivante :</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb71-1" title="1">resultats[i] &lt;-<span class="st"> </span>tirage</a></code></pre></div>
<p>la modification s’effectue sans réallocation de mémoire à chaque itération si :</p>
<ul>
<li>l’objet en question est un objet atomique (vecteur, matrice ou array) ou une liste;</li>
<li>la valeur assignée est du même type que les éléments de l’objet initialisé (dans le cas d’un objet atomique);</li>
<li>l’objet possède au moins autant d’éléments que le nombre d’itérations effectuées.</li>
</ul>
<p>Pour nous en convaincre, faisons quelques tests en utilisant la fonction <code>tracemem</code> qui affiche un message à chaque fois qu’un objet est copié en mémoire.</p>
<p>Voici une boucle qui modifie les éléments d’une matrice.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" title="1">matrice &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA_integer_</span>, <span class="dv">4</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb72-2" title="2"><span class="kw">tracemem</span>(matrice)</a></code></pre></div>
<pre><code>[1] &quot;&lt;0000000019C9B820&gt;&quot;</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb74-1" title="1"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>){</a>
<a class="sourceLine" id="cb74-2" title="2">  matrice[, i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb74-3" title="3">}</a></code></pre></div>
<pre><code>tracemem[0x0000000019c9b820 -&gt; 0x0000000019f53170]: </code></pre>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb76-1" title="1"><span class="kw">untracemem</span>(matrice)</a></code></pre></div>
<p>L’objet <code>matrice</code> est copié une seule fois, au début de la boucle, mais pas à chaque itération.</p>
<p>Nous observons le même comportement avec une liste.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" title="1">liste &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="dt">mode =</span> <span class="st">&quot;list&quot;</span>, <span class="dt">length =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb77-2" title="2"><span class="kw">tracemem</span>(liste)</a></code></pre></div>
<pre><code>[1] &quot;&lt;000000001A2DC048&gt;&quot;</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" title="1"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>){</a>
<a class="sourceLine" id="cb79-2" title="2">  liste[[i]] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb79-3" title="3">}</a></code></pre></div>
<pre><code>tracemem[0x000000001a2dc048 -&gt; 0x0000000019d88738]: </code></pre>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb81-1" title="1"><span class="kw">untracemem</span>(liste)</a></code></pre></div>
<p>Cependant, R se comporte différemment lors de la modification d’un élément dans un data frame</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb82-1" title="1">df &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">matrix</span>(<span class="ot">NA_integer_</span>, <span class="dv">4</span>, <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb82-2" title="2"><span class="kw">tracemem</span>(df)</a></code></pre></div>
<pre><code>[1] &quot;&lt;0000000019B7D730&gt;&quot;</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb84-1" title="1"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>){</a>
<a class="sourceLine" id="cb84-2" title="2">  df[, i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb84-3" title="3">}</a></code></pre></div>
<pre><code>tracemem[0x0000000019b7d730 -&gt; 0x0000000018e92818]: 
tracemem[0x0000000018e92818 -&gt; 0x0000000018e92950]: [&lt;-.data.frame [&lt;- 
tracemem[0x0000000018e92950 -&gt; 0x0000000018e929b8]: [&lt;-.data.frame [&lt;- 
tracemem[0x0000000018e929b8 -&gt; 0x0000000018e92a20]: 
tracemem[0x0000000018e92a20 -&gt; 0x0000000018e92b58]: [&lt;-.data.frame [&lt;- 
tracemem[0x0000000018e92b58 -&gt; 0x0000000018e92bc0]: [&lt;-.data.frame [&lt;- 
tracemem[0x0000000018e92bc0 -&gt; 0x0000000018e92c28]: 
tracemem[0x0000000018e92c28 -&gt; 0x000000001a2ab810]: [&lt;-.data.frame [&lt;- 
tracemem[0x000000001a2ab810 -&gt; 0x000000001a2ab878]: [&lt;-.data.frame [&lt;- 
tracemem[0x000000001a2ab878 -&gt; 0x000000001a2ab8e0]: 
tracemem[0x000000001a2ab8e0 -&gt; 0x000000001a2aba18]: [&lt;-.data.frame [&lt;- 
tracemem[0x000000001a2aba18 -&gt; 0x000000001a2aba80]: [&lt;-.data.frame [&lt;- 
tracemem[0x000000001a2aba80 -&gt; 0x000000001a2abae8]: 
tracemem[0x000000001a2abae8 -&gt; 0x000000001a2abc20]: [&lt;-.data.frame [&lt;- 
tracemem[0x000000001a2abc20 -&gt; 0x000000001a2abc88]: [&lt;-.data.frame [&lt;- </code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb86-1" title="1"><span class="kw">untracemem</span>(df)</a></code></pre></div>
<p>À chaque itération de cette boucle, l’objet <code>df</code> est recopié 3 fois. Ces allocations de mémoire répétées prennent du temps.</p>
<p>La lenteur des opérations de manipulation de data frame est bien connue en R. Des alternatives plus rapides existent, notamment les data tables offerts par le <a href="https://CRAN.R-project.org/package=data.table">package <code>data.table</code></a>. Ce package a été mentionné à quelques reprises dans ce cours, notamment dans les notes sur le <a href="https://stt4230.rbind.io/manipulation_donnees/pretraitement_donnees_r/">prétraitement de données en R</a>. Certaines fonctions de ce package permettent la modification de data table « par référence », donc sans créer de copies de l’objet et nécessiter des allocations de mémoire.</p>
<p>Reprenons l’exemple de la simulation d’une expérience aléatoire de lancers d’un dé jusqu’à l’atteinte d’une certaine somme cumulative des valeurs obtenues. Voici deux autres fonctions réalisant cette expérience, qui diffèrent seulement par le type de l’objet utilisé pour stocker les résultats. La fonction <code>somme_de_data_frame</code> utilise un data frame, la fonction <code>somme_de_matrice</code> une matrice et la fonction <code>somme_de_data_table</code> un data table.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb87-1" title="1"><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></a>
<a class="sourceLine" id="cb87-2" title="2"><span class="co">#&#39; @description Version utilisant un data frame pour stocker les résultats</span></a>
<a class="sourceLine" id="cb87-3" title="3"><span class="co">#&#39; @param somme_visee somme cumulative de valeurs obtenues à atteindre (par défaut 50000)</span></a>
<a class="sourceLine" id="cb87-4" title="4"><span class="co">#&#39; @return data frame possédant une ligne par lancer, contenant le numéro de lancer</span></a>
<a class="sourceLine" id="cb87-5" title="5"><span class="co">#&#39;         dans la première colonne et le résultat obtenu dans la deuxième colonne</span></a>
<a class="sourceLine" id="cb87-6" title="6">somme_de_data_frame &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">somme_visee =</span> <span class="dv">50000</span>){</a>
<a class="sourceLine" id="cb87-7" title="7">  resultats &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">matrix</span>(<span class="ot">NA_integer_</span>, <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">nrow =</span> somme_visee))</a>
<a class="sourceLine" id="cb87-8" title="8">  resultats[, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>somme_visee  <span class="co"># Colonne 1 = numéro de l&#39;itération</span></a>
<a class="sourceLine" id="cb87-9" title="9">  somme &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb87-10" title="10">  i &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb87-11" title="11">  <span class="cf">while</span>(somme <span class="op">&lt;</span><span class="st"> </span>somme_visee) {</a>
<a class="sourceLine" id="cb87-12" title="12">    tirage &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">size =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb87-13" title="13">    somme &lt;-<span class="st"> </span>somme <span class="op">+</span><span class="st"> </span>tirage</a>
<a class="sourceLine" id="cb87-14" title="14">    i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb87-15" title="15">    resultats[i, <span class="dv">2</span>] &lt;-<span class="st"> </span>tirage  <span class="co"># Colonne 2 = résultat obtenu au lancer du dé</span></a>
<a class="sourceLine" id="cb87-16" title="16">  }</a>
<a class="sourceLine" id="cb87-17" title="17">  resultats[<span class="dv">1</span><span class="op">:</span>i, ]</a>
<a class="sourceLine" id="cb87-18" title="18">}</a></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" title="1"><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></a>
<a class="sourceLine" id="cb88-2" title="2"><span class="co">#&#39; @description Version utilisant une matrice pour stocker les résultats</span></a>
<a class="sourceLine" id="cb88-3" title="3"><span class="co">#&#39; @param somme_visee somme cumulative de valeurs obtenues à atteindre (par défaut 50000)</span></a>
<a class="sourceLine" id="cb88-4" title="4"><span class="co">#&#39; @return matrice possédant une ligne par lancer, contenant le numéro de lancer</span></a>
<a class="sourceLine" id="cb88-5" title="5"><span class="co">#&#39;         dans la première colonne et le résultat obtenu dans la deuxième colonne</span></a>
<a class="sourceLine" id="cb88-6" title="6">somme_de_matrice &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">somme_visee =</span> <span class="dv">50000</span>){</a>
<a class="sourceLine" id="cb88-7" title="7">  resultats &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA_integer_</span>, <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">nrow =</span> somme_visee)</a>
<a class="sourceLine" id="cb88-8" title="8">  resultats[, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>somme_visee  <span class="co"># Colonne 1 = numéro de l&#39;itération</span></a>
<a class="sourceLine" id="cb88-9" title="9">  somme &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb88-10" title="10">  i &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb88-11" title="11">  <span class="cf">while</span>(somme <span class="op">&lt;</span><span class="st"> </span>somme_visee) {</a>
<a class="sourceLine" id="cb88-12" title="12">    tirage &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">size =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb88-13" title="13">    somme &lt;-<span class="st"> </span>somme <span class="op">+</span><span class="st"> </span>tirage</a>
<a class="sourceLine" id="cb88-14" title="14">    i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb88-15" title="15">    resultats[i, <span class="dv">2</span>] &lt;-<span class="st"> </span>tirage  <span class="co"># Colonne 2 = résultat obtenu au lancer du dé</span></a>
<a class="sourceLine" id="cb88-16" title="16">  }</a>
<a class="sourceLine" id="cb88-17" title="17">  resultats[<span class="dv">1</span><span class="op">:</span>i, ]</a>
<a class="sourceLine" id="cb88-18" title="18">}</a></code></pre></div>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb89-1" title="1"><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></a>
<a class="sourceLine" id="cb89-2" title="2"><span class="co">#&#39; @description Version utilisant un data table pour stocker les résultats</span></a>
<a class="sourceLine" id="cb89-3" title="3"><span class="co">#&#39; @param somme_visee somme cumulative de valeurs obtenues à atteindre (par défaut 50000)</span></a>
<a class="sourceLine" id="cb89-4" title="4"><span class="co">#&#39; @return data table possédant une ligne par lancer, contenant le numéro de lancer</span></a>
<a class="sourceLine" id="cb89-5" title="5"><span class="co">#&#39;         dans la première colonne et le résultat obtenu dans la deuxième colonne</span></a>
<a class="sourceLine" id="cb89-6" title="6">somme_de_data_table &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">somme_visee =</span> <span class="dv">50000</span>){</a>
<a class="sourceLine" id="cb89-7" title="7">  resultats &lt;-<span class="st"> </span><span class="kw">as.data.table</span>(<span class="kw">matrix</span>(<span class="ot">NA_integer_</span>, <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">nrow =</span> somme_visee))</a>
<a class="sourceLine" id="cb89-8" title="8">  <span class="kw">set</span>(resultats, <span class="dt">j =</span> 1L, <span class="dt">value =</span> <span class="dv">1</span><span class="op">:</span>somme_visee)</a>
<a class="sourceLine" id="cb89-9" title="9">  somme &lt;-<span class="st"> </span>0L</a>
<a class="sourceLine" id="cb89-10" title="10">  i &lt;-<span class="st"> </span>0L</a>
<a class="sourceLine" id="cb89-11" title="11">  <span class="cf">while</span>(somme <span class="op">&lt;</span><span class="st"> </span>somme_visee) {</a>
<a class="sourceLine" id="cb89-12" title="12">    tirage &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">size =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb89-13" title="13">    somme &lt;-<span class="st"> </span>somme <span class="op">+</span><span class="st"> </span>tirage</a>
<a class="sourceLine" id="cb89-14" title="14">    i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span>1L</a>
<a class="sourceLine" id="cb89-15" title="15">    <span class="kw">set</span>(resultats, <span class="dt">i =</span> i, <span class="dt">j =</span> 2L, <span class="dt">value =</span> tirage)</a>
<a class="sourceLine" id="cb89-16" title="16">  }</a>
<a class="sourceLine" id="cb89-17" title="17">  resultats[<span class="dv">1</span><span class="op">:</span>i, ]</a>
<a class="sourceLine" id="cb89-18" title="18">}</a></code></pre></div>
<p>Dans la fonction <code>somme_de_data_table</code>, nous avons pris soin de modifier le data table par référence en utilisant la <a href="https://rdatatable.gitlab.io/data.table/reference/assign.html">fonction <code>set</code></a> du package <code>data.table</code>.</p>
<p>Quelle fonction est la plus rapide?</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" title="1"><span class="kw">library</span>(data.table)</a>
<a class="sourceLine" id="cb90-2" title="2">ex_compar_df &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb90-3" title="3">  <span class="kw">somme_de_data_frame</span>(),</a>
<a class="sourceLine" id="cb90-4" title="4">  <span class="kw">somme_de_matrice</span>(),</a>
<a class="sourceLine" id="cb90-5" title="5">  <span class="kw">somme_de_data_table</span>(),</a>
<a class="sourceLine" id="cb90-6" title="6">  <span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="dt">check =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb90-7" title="7">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" title="1"><span class="kw">print_bench_mark</span>(ex_compar_df)</a></code></pre></div>
<pre><code>##              expression n_itr      min    median mem_alloc n_gc
## 1 somme_de_data_frame()    10 883.7985 994.50630    2.69GB  468
## 2    somme_de_matrice()    10  59.1296  63.41755    35.5MB    9
## 3 somme_de_data_table()    10  89.1770  93.23125   38.44MB   12</code></pre>
<p>Ici, l’utilisation du data frame est environ 16 fois plus lente que l’utilisation d’une matrice (et utilise plus de mémoire)! L’utilisation d’un data table est juste un peu plus lente que l’utilisation d’une matrice, mais le data table a l’avantage de pouvoir stocker des données de types différents entre ses colonnes.</p>
<p>Le message à retenir ici est, qu’autant que possible, il vaut mieux <strong>éviter d’utiliser un data frame pour stocker des résultats générés dans une boucle</strong>.</p>
<!---
## Astuce 6&nbsp;:  Utiliser de la compilation en bytecode

La compilation en bytecode (en anglais *byte code compilation*) consiste en une étape de compilation intermédiaire entre les instructions-machine et le code source. En R, le package `compiler` permet de faire facilement de la compilation en bytecode. Ce package vient avec l'installation de base de R (il est donc déjà installé pour vous, comme le package `parallel`).

En fait, depuis la version 3.4.0 de R, de la compilation bytecode est réalisée par défaut, dès que possible, sans que l'utilisateur ait à appeler lui-même une fonction du package `compiler`. Pour illustrer les gains apportés par la compilation en bytecode, commençons par demander à R de ne pas en réaliser par défaut avec la commande suivante.


```r
library(compiler)
enableJIT(0)
```

Retournons à l'exemple des fonctions `ksmooth` pour estimer une densité par la méthode du noyau pour illustrer la compilation bytecode. Nous allons créé des versions « bytecode compilées » de notre fonction originale, `ksmooth_double_loop`, et de notre fonction la plus rapide `ksmooth_loop`. 


```r
ksmooth_double_loop_byte <- cmpfun(ksmooth_double_loop)
ksmooth_loop_byte <- cmpfun(ksmooth_loop)
```

Maintenant, comparons les temps d'exécution de ces fonctions avec leurs versions non « bytecode compilées ».


```r
microbenchmark(unit = "ms",
       dens_ksmooth_double_loop = ksmooth_double_loop(x = x, xpts = xpts, h = 1), 
  dens_ksmooth_double_loop_byte = ksmooth_double_loop_byte(x = x, xpts = xpts, h = 1),
       dens_ksmooth_loop = ksmooth_loop(x = x, xpts = xpts, h = 1),
  dens_ksmooth_loop_byte = ksmooth_loop_byte(x = x, xpts = xpts, h = 1))
```

Bon, cette technique n'est pas magique, mais c'est mieux que rien. Avec à peu près aucun effort de programmation (seul un appel à fonction `cmpfun` a été nécessaire), nous avons réduit de moitié le temps d'exécution de la double boucle dans `ksmooth_double_loop`. Par contre, avec du calcul vectoriel, cette technique n'apporte pas toujours de gain en temps d'exécution, comme nous pouvons le constater avec la fonction `ksmooth_loop`.

Le R core team cherche toujours à rendre R le plus rapide possible. Effectuer de la compilation bytecode par défaut est un exemple de modification du logiciel qui l'a rendu plus rapide. Redonnons à R son comportement par défaut avec la commande suivante.


```r
enableJIT(3)
```

--->
</div>
</div>
<div id="astuce-5-faire-du-calcul-en-parallèle" class="section level2">
<h2>Astuce 5 : Faire du calcul en parallèle</h2>
<p>Une importante technique pour réaliser des calculs informatiques plus rapidement est le calcul en parallèle. Il s’agit d’un type de calcul qui, dans sa version la plus simple,</p>
<ul>
<li>brise un long calcul en petits blocs de calcul indépendants;</li>
<li>réalise ces blocs de calcul sur plusieurs unités de calcul, simultanément (donc en parallèle);</li>
<li>rassemble à la fin tous les résultats.</li>
</ul>
<p>Les unités de calcul utilisées peuvent être localisées sur CPU (pour <em>Central Processing Unit</em>) ou sur GPU (pour <em>Graphical Processing Unit</em>). Nous pouvons exploiter différentes unités sur une seule machine ou encore sur plusieurs noeuds de calcul dans une grappe de serveurs.</p>
<p>Je vais réaliser un exemple dans lequel je vais exploiter tous les coeurs du CPU de mon ordinateur.</p>
<p>Il existe un très grand nombre de packages R pour réaliser du calcul en parallèle (<a href="https://cran.r-project.org/web/views/HighPerformanceComputing.html" class="uri">https://cran.r-project.org/web/views/HighPerformanceComputing.html</a>). Un de ces packages vient avec l’installation de R. Il s’agit du package <code>parallel</code>. Ce package est donc déjà installé sur votre ordinateur si R y est installé. Cependant, le package n’est pas chargé par défaut lors de l’ouverture d’une nouvelle session R. Chargeons-le.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" title="1"><span class="kw">library</span>(parallel)</a></code></pre></div>
<p>Tout d’abord, voyons combien de coeurs compte mon ordinateur.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" title="1"><span class="kw">detectCores</span>()</a></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p>Il compte 4 coeurs logiques.</p>
<p>Maintenant, si nous travaillons sous Windows, il faut d’abord établir une connexion entre R est les différents coeurs avec la fonction <code>makeCluster</code>.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" title="1">coeurs &lt;-<span class="st"> </span><span class="kw">detectCores</span>()</a>
<a class="sourceLine" id="cb97-2" title="2">grappe &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(coeurs <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb97-3" title="3">grappe</a></code></pre></div>
<pre><code>## socket cluster with 3 nodes on host &#39;localhost&#39;</code></pre>
<p>Notons que la première fois que j’ai soumis cette commande, Windows m’a demandé une autorisation.</p>
<p>Remarquons aussi que je n’ai utilisé que 3 des 4 coeurs disponibles sur mon ordinateur dans le but de laisser un coeur libre pour les autres processus actifs.</p>
<p>Ensuite, je vais comparer la fonction <code>ksmooth_apply</code>, qui utilise <code>sapply</code>, à une autre version de <code>ksmooth</code> qui utilise la version parallèle du <code>sapply</code> offerte par le package <code>parallel</code>, nommée <code>parSapply</code>.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" title="1"><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></a>
<a class="sourceLine" id="cb99-2" title="2"><span class="co">#&#39; @description Version 5 : utilisation de parSapply et d&#39;un calcul vectoriel</span></a>
<a class="sourceLine" id="cb99-3" title="3"><span class="co">#&#39; @inherit ksmooth_double_loop params return</span></a>
<a class="sourceLine" id="cb99-4" title="4">ksmooth_parallel &lt;-<span class="st"> </span><span class="cf">function</span>(grappe, x, xpts, h)</a>
<a class="sourceLine" id="cb99-5" title="5">{</a>
<a class="sourceLine" id="cb99-6" title="6">  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb99-7" title="7">  <span class="kw">parSapply</span>(</a>
<a class="sourceLine" id="cb99-8" title="8">    <span class="dt">cl =</span> grappe,</a>
<a class="sourceLine" id="cb99-9" title="9">    <span class="dt">X =</span> xpts,</a>
<a class="sourceLine" id="cb99-10" title="10">    <span class="dt">FUN =</span> <span class="cf">function</span>(xpts_i) {</a>
<a class="sourceLine" id="cb99-11" title="11">      <span class="kw">sum</span>(<span class="kw">dnorm</span>((xpts_i <span class="op">-</span><span class="st"> </span>x) <span class="op">/</span><span class="st"> </span>h)) <span class="op">/</span><span class="st"> </span>(n <span class="op">*</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb99-12" title="12">    }</a>
<a class="sourceLine" id="cb99-13" title="13">  )</a>
<a class="sourceLine" id="cb99-14" title="14">}</a></code></pre></div>
<p>Ces fonctions effectuent bien le même calcul.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" title="1">densite_ka &lt;-<span class="st"> </span><span class="kw">ksmooth_apply</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb100-2" title="2">densite_kp &lt;-<span class="st"> </span><span class="kw">ksmooth_parallel</span>(<span class="dt">grappe =</span> grappe, <span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb100-3" title="3"></a>
<a class="sourceLine" id="cb100-4" title="4"><span class="kw">all.equal</span>(densite_ka, densite_kp)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Laquelle est la plus rapide?</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb102-1" title="1">ex_astuce_<span class="dv">5</span> &lt;-<span class="st"> </span><span class="kw">mark</span>(<span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;ms&quot;</span>,</a>
<a class="sourceLine" id="cb102-2" title="2">     <span class="dt">v4_sapply =</span> <span class="kw">ksmooth_apply</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>), </a>
<a class="sourceLine" id="cb102-3" title="3">  <span class="dt">v5_parSapply =</span> <span class="kw">ksmooth_parallel</span>(<span class="dt">grappe =</span> grappe, <span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb102-4" title="4">)</a>
<a class="sourceLine" id="cb102-5" title="5"><span class="kw">print_bench_mark</span>(ex_astuce_<span class="dv">5</span>)</a></code></pre></div>
<pre><code>##     expression n_itr     min  median mem_alloc n_gc
## 1    v4_sapply    29 12.9709 16.7963     2.6MB    1
## 2 v5_parSapply    55  7.9939  9.0849   121.5KB    0</code></pre>
<p>Le calcul en parallèle a permis de réduire un peu le temps d’exécution. Même si 3 coeurs ont été exploités, le calcul n’est pas 3 fois plus rapide, car :</p>
<ul>
<li>mon ordinateur possède en fait 2 coeurs physiques, chacun séparé en 2 coeurs logiques (pour un total de 4 coeurs logiques), et des coeurs logiques ne sont pas aussi rapides que des coeurs physiques;</li>
<li>toutes les communications entre les coeurs et R requièrent aussi un peu de temps.</li>
</ul>
<p>Une fois le calcul terminé, il est recommandé de fermer les connexions entre R et les coeurs de calcul avec la fonction <code>stopCluster</code>.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb104-1" title="1"><span class="kw">stopCluster</span>(grappe)</a></code></pre></div>
<p>Nous aurions pu aller chercher une amélioration plus importante du temps de calcul en utilisant plus d’unités de calcul. Le département de mathématiques et de statistique possède une grappe de calcul pouvant être utilisée par les étudiants du département pour faire du calcul en parallèle. <a href="http://www.calculquebec.ca/fr/">Calcul Québec</a> gère aussi des supercalculateurs pour le calcul en parallèle utilisable gratuitement par tout chercheur (et ses étudiants) admissible aux subventions provenant des conseils de recherche canadiens, à la condition d’avoir obtenu des accès aux ressources : <a href="http://www.calculquebec.ca/fr/acces-aux-ressources" class="uri">http://www.calculquebec.ca/fr/acces-aux-ressources</a>. Finalement, plusieurs plateformes de <a href="https://fr.wikipedia.org/wiki/Cloud_computing"><em>cloud computing</em></a> permettent d’utiliser des serveurs de calculs à faible coût (par exemple <a href="https://aws.amazon.com">Amazon Web Services</a>, <a href="https://azure.microsoft.com">Microsoft Azure</a>, <a href="https://cloud.google.com/">Google Cloud Platform</a>).</p>
<p>Lancer des calculs en parallèle sur une grappe de calcul ne s’effectue pas tout à fait comme le lancement de calculs en parallèle sur une seule machine. La communication avec la grappe s’effectue typiquement via des protocoles SSH et les programmes R se lancent en mode batch grâce à la commande <code>Rscript</code>. Ce sujet ne sera pas couvert ici, car il est plutôt complexe et la mise en oeuvre de calculs en parallèle dépend des ressources à notre disposition. Pour plus d’informations, je vous réfère à un document que j’ai écrit sur le sujet, qui est disponible ici : <a href="https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/" class="uri">https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/</a>.</p>
</div>
<div id="astuce-6-reprogrammer-en-c-ou-c-les-bouts-de-code-les-plus-lents" class="section level2">
<h2>Astuce 6 : Reprogrammer en C ou C++ les bouts de code les plus lents</h2>
<p><em>Note : La matière présentée dans cette section ne sera pas évaluée.</em></p>
<p>Une dernière astuce pour rendre du code R plus rapide est de reprogrammer ses bouts les plus lents en C ou C++. Le langage R étant un langage interprété, il n’est pas aussi rapide que du C ou du C++, qui sont des langages de plus bas niveau, plus près du langage machine.</p>
<p>Nous n’utilisons pas cette astuce pour réaliser des analyses de données plus rapidement, mais plutôt pour créer une fonction qui réalise rapidement un certain calcul.</p>
<p>Il existe quelques outils pour intégrer du code C ou C++ en R. Un outil très populaire pour intégrer du code C++ en R est le package <code>Rcpp</code> (<a href="http://www.rcpp.org/" class="uri">http://www.rcpp.org/</a>). Le R de base offre pour sa part les fonctions <code>.C</code>, <code>.Call</code> et <code>.External</code> pour ce faire (voir le manuel <a href="http://cran.r-project.org/doc/manuals/r-release/R-exts.html#System-and-foreign-language-interfaces"><em>Writing R Extensions</em>, chapitre 5)</a>. Je vais me contenter ici d’illustrer l’utilisation de la fonction <code>.C</code>, qui est la méthode la plus simple, mais la moins puissante.</p>
<p>La fonction <code>ksmooth_double_loop</code> peut être reprogrammée en C comme suit (<a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw, 2002</a>) :</p>
<pre><code>#include &lt;R.h&gt;
#include &lt;Rmath.h&gt;

void kernel_smooth(double *x, int *n, double *xpts,
       int *nxpts, double *h, double *result)
{
 int i, j;
 double d, ksum;

 for(i=0; i &lt; *nxpts; i++) 
 {
  ksum = 0;
  for(j=0; j &lt; *n; j++) 
  {
   d = xpts[i] - x[j];
   ksum += dnorm(d / *h, 0, 1, 0);
  }
  result[i] = ksum / ((*n) * (*h));
 }
}</code></pre>
<p>Du code C destiné à être appelé en R avec la fonction <code>.C</code> se doit de respecter les propriétés suivantes (<a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw, 2002</a>) :</p>
<ul>
<li><p>Les fonctions C appelées en R doivent être de type « void ». Elles doivent retourner les résultats des calculs par leurs arguments.</p></li>
<li><p>Les arguments passés aux fonctions C sont des pointeurs à un nombre ou à un tableau. Il faut donc correctement déréférencer les pointeurs dans le code C afin d’obtenir la valeur d’un élément dont l’adresse est contenue dans le pointeur. Un pointeur est déréférencé en ajoutant <code>*</code> devant celui-ci.</p></li>
<li><p>Il est préférable d’inclure dans tout fichier contenant du code C à être appelé en R le fichier d’en-tête R.h en ajoutant au début du fichier de code C la ligne :</p></li>
</ul>
<pre><code>#include &lt;R.h&gt; </code></pre>
<p>De plus, il est possible d’utiliser en C certaines fonctions mathématiques R en incluant le fichier d’en-tête Rmath.h dans le fichier de code C par la ligne :</p>
<pre><code>#include &lt;Rmath.h&gt;</code></pre>
<p>Les fonctions mathématiques R utilisables en C sont énumérées dans le manuel de R <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-R-API"><em>Writing R Extensions</em>, chapitre 6</a>.</p>
<ul>
<li>Le fichier contenant le code C doit porter l’extension <em>.c</em>.</li>
</ul>
<p>Une fois le code C écrit, il reste trois étapes à compléter pour intégrer du code C en R avec la fonction <code>.C</code>.</p>
<ol style="list-style-type: decimal">
<li>Compiler le code C afin de créer un objet partagé si nous travaillons sur Linux ou une « bibliothèque de liens dynamiques » (an anglais <em>DLL</em>) si nous travaillons sur Windows ou Mac OS X ;</li>
<li>Charger en R l’objet partagé ou le DLL créé à l’étape précédente avec la fonction <code>dyn.load</code> ;</li>
<li>Appeler en R les fonctions créées dans le code C avec la fonction d’interface <code>.C</code>.</li>
</ol>
<p>Retournons donc à l’exemple. Supposons que le code C ci-dessus se trouve dans le fichier <code>C:/coursR/ksmoothC.c</code>. Dans le <em>terminal</em> sous Linux ou Mac OS X et dans une <em>fenêtre invite de commandes</em> sous Windows, il faut se positionner dans le répertoire contenant le fichier et lancer la commande suivante :</p>
<pre><code>R CMD SHLIB ksmoothC.c</code></pre>
<p>Notons qu’en RStudio, nous pouvons facilement ouvrir un terminal ou une fenêtre invite de commandes par le menu <em>Tools &gt; Shell…</em>.</p>
<p>Cette commande fonctionnera seulement si un compilateur C/C++ est installé sur l’ordinateur. Les <a href="https://stt4230.rbind.io/introduction/installation_r_rstudio/#tools">outils nécessaires au développement de packages R</a> en fournissent un. Si la commande a fonctionné, l’objet partagé ou le DLL sera créé. Sur Windows, il s’agit d’un fichier portant l’extension <em>.dll</em>.</p>
<p>Maintenant, chargeons cet objet en R avec la fonction <code>dyn.load</code>, comme dans cet exemple réalisé sur Windows :</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" title="1"><span class="kw">dyn.load</span>(<span class="st">&quot;C:/coursR/ksmoothC.dll&quot;</span>)</a></code></pre></div>
<p>Il ne reste plus qu’à écrire la « fonction R enveloppe », qui appelle la fonction écrite en C, comme dans cet exemple (fonction <code>ksmooth3</code> de <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw 2002</a> renommée ici <code>ksmooth_C</code>) :</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb110-1" title="1"><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></a>
<a class="sourceLine" id="cb110-2" title="2"><span class="co">#&#39; @description Version 6 : code C + appel à la fonction .C</span></a>
<a class="sourceLine" id="cb110-3" title="3"><span class="co">#&#39; @inherit ksmooth_double_loop params return</span></a>
<a class="sourceLine" id="cb110-4" title="4">ksmooth_C &lt;-<span class="st"> </span><span class="cf">function</span>(x, xpts, h) {</a>
<a class="sourceLine" id="cb110-5" title="5">  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb110-6" title="6">  nxpts &lt;-<span class="st"> </span><span class="kw">length</span>(xpts)</a>
<a class="sourceLine" id="cb110-7" title="7">  dens &lt;-<span class="st"> </span><span class="kw">.C</span>(<span class="st">&quot;kernel_smooth&quot;</span>, <span class="kw">as.double</span>(x), <span class="kw">as.integer</span>(n),</a>
<a class="sourceLine" id="cb110-8" title="8">             <span class="kw">as.double</span>(xpts), <span class="kw">as.integer</span>(nxpts), <span class="kw">as.double</span>(h),</a>
<a class="sourceLine" id="cb110-9" title="9">             <span class="dt">result =</span> <span class="kw">double</span>(<span class="kw">length</span>(xpts)))</a>
<a class="sourceLine" id="cb110-10" title="10">  dens<span class="op">$</span>result</a>
<a class="sourceLine" id="cb110-11" title="11">}</a></code></pre></div>
<p>Dans l’appel à la fonction <code>.C</code>, le nom de la fonction doit obligatoirement être entre guillemets. Il est préférable de s’assurer que chaque argument passé à la fonction C est du bon type en appliquant aux arguments une fonction telle <code>as.integer</code>, <code>as.double</code>, <code>as.character</code> ou <code>as.logical</code>.</p>
<p>Est-ce que la fonction <code>ksmooth_C</code> effectue bien le même calcul que <code>ksmooth_double_loop</code>?</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" title="1">densite_kdl &lt;-<span class="st"> </span><span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb111-2" title="2">densite_kC &lt;-<span class="st"> </span><span class="kw">ksmooth_C</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb111-3" title="3"></a>
<a class="sourceLine" id="cb111-4" title="4"><span class="kw">all.equal</span>(densite_kdl, densite_kC)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Oui.</p>
<p>Maintenant, voyons si cette nouvelle version de <code>ksmooth</code> est plus rapide que certaines des autres fonctions que nous avons développées. Comparons aussi <code>ksmooth_C</code> à la fonction <code>density</code></p>
<!--
Le bloc suivant n'était pas évalué, car il provoquait une erreur lorsqu'évalué
à partir du doc RMarkdown, mais pas lorsqu'évalué dans la console.
-->
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" title="1">ex_astuce_<span class="dv">6</span> &lt;-<span class="st"> </span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb113-2" title="2">  <span class="dt">ksmooth_double_loop =</span> <span class="kw">ksmooth_double_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>), </a>
<a class="sourceLine" id="cb113-3" title="3">  <span class="dt">ksmooth_outer =</span> <span class="kw">ksmooth_outer</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb113-4" title="4">  <span class="dt">ksmooth_loop =</span> <span class="kw">ksmooth_loop</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb113-5" title="5">  <span class="dt">ksmooth_C =</span> <span class="kw">ksmooth_C</span>(<span class="dt">x =</span> x, <span class="dt">xpts =</span> xpts, <span class="dt">h =</span> <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb113-6" title="6">  <span class="dt">density =</span> <span class="kw">density</span>(<span class="dt">x =</span> x, <span class="dt">bw =</span> <span class="dv">1</span>, <span class="dt">kernel =</span> <span class="st">&quot;gaussian&quot;</span>, <span class="dt">from =</span> <span class="dv">-4</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">n =</span> <span class="dv">17</span>),</a>
<a class="sourceLine" id="cb113-7" title="7">  <span class="dt">min_iterations =</span> <span class="dv">10</span>, <span class="dt">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="dt">check =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb113-8" title="8">)</a></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb115-1" title="1"><span class="kw">print_bench_mark</span>(ex_astuce_<span class="dv">6</span>)</a></code></pre></div>
<pre><code>##            expression n_itr      min   median mem_alloc n_gc
## 1 ksmooth_double_loop    10 207.3071 232.9343      184B   30
## 2       ksmooth_outer    31  12.9479  16.5305    6.49MB    3
## 3        ksmooth_loop    33  12.4694  15.8571     2.6MB    1
## 4           ksmooth_C    41  10.4393  12.7336  111.87KB    0
## 5             density   645   0.4604   0.7513  315.33KB    4</code></pre>
<!---
```
## Unit: milliseconds
##       expr        min         lq        mean      median          uq        max neval
##   ksmooth_double_loop 160.018944 164.591159 170.1964157 167.9260415 170.7282935 220.236163   100
##   ksmooth_outer  13.402644  13.713477  15.6816264  14.8917480  16.5846660  61.744760   100
##   ksmooth_loop  12.471381  12.584219  14.0803544  12.7721640  14.8104705  58.695675   100
##  ksmooth_C  10.264700  10.315124  10.6443776  10.3643150  10.5529655  13.869510   100
##    density   0.513059   0.635065   0.6897806   0.6770265   0.7061175   1.384377   100
```
--->
<p>La fonction <code>ksmooth_C</code> bat <code>ksmooth_double_loop</code> (double boucle), <code>ksmooth_outer</code> (calcul vectoriel seul avec <code>outer</code>) et <code>ksmooth_loop</code> (boucle et calcul vectoriel), quoiqu’elle n’est pas beaucoup plus rapide que ces deux dernières. Cependant, <code>density</code> demeure beaucoup plus rapide que tout ce que nous avons programmé.</p>
<p>Mais pourquoi <code>density</code> est-il tellement plus rapide alors qu’elle fait appel à du code C, tout comme <code>ksmooth_C</code>? Premièrement, parce que ce code C est interfacé en R par la fonction <code>.Call</code> plutôt que <code>.C</code>. L’interface <code>.Call</code> est plus compliquée d’utilisation que <code>.C</code>, mais plus efficace. La fonction <code>density</code> est aussi plus rapide parce que son code C a lui aussi été optimisé.</p>
<hr />
</div>
</div>
<div id="résumé" class="section level1">
<h1>Résumé</h1>
<div id="optimisation-de-temps-dexécution" class="section level4">
<h4>Optimisation de temps d’exécution</h4>

<p>Outils pour analyser la performance d’un programme R :</p>
<ul>
<li>calcul global de temps d’exécution :
<ul>
<li>la fonction <code>system.time</code> (R de base),</li>
<li>la fonction <code>mark</code> du package <code>bench</code>;</li>
</ul></li>
<li>calcul plus détaillé de temps d’exécution :
<ul>
<li>par fonction appelée (<em>call stack</em>) : les fonctions <code>Rprof</code> et <code>summaryRprof</code> (R de base),</li>
<li>par ligne de code : la fonction <code>profvis</code> (package du même nom).</li>
</ul></li>
</ul>
<p><strong>Conseil</strong> : comparaison de différentes options.<br />
<span class="math inline">\(\longrightarrow\)</span> Le code le plus rapide n’est pas toujours celui que nous croyons.</p>
<p>Contrainte : <strong>compromis temps d’exécution - quantité de mémoire utilisée</strong></p>
</div>
<div id="stratégies-doptimisation-du-temps-dexécution-1" class="section level4">
<h4>Stratégies d’optimisation du temps d’exécution</h4>

<p><strong>Astuces</strong> pour du code R plus rapide :</p>
<ol style="list-style-type: decimal">
<li>Utiliser des fonctions optimisées</li>
<li>Faire seulement ce qui est nécessaire</li>
<li>Exploiter les calculs matriciels et vectoriels</li>
<li>Éviter les allocations de mémoire inutiles</li>
<li>Faire du calcul en parallèle</li>
<li>Reprogrammer en C ou C++ les bouts de code les plus lents</li>
</ol>
<div id="astuce-1-utiliser-des-fonctions-optimisées-1" class="section level5">
<h5>Astuce 1 : Utiliser des fonctions optimisées</h5>

<p>Profiter du travail des autres</p>
<p>Le web regorge de fonctions R : la distribution de base de R, le CRAN, Bioconductor, etc.</p>
</div>
<div id="astuce-2-faire-seulement-ce-qui-est-nécessaire-1" class="section level5">
<h5>Astuce 2 : Faire seulement ce qui est nécessaire</h5>

<p>Ne pas alourdir son code d’évaluations inutiles</p>
</div>
<div id="astuce-3-exploiter-les-calculs-matriciels-et-vectoriels-1" class="section level5">
<h5>Astuce 3 : Exploiter les calculs matriciels et vectoriels</h5>

<p>R est optimisé pour le calcul vectoriel</p>
<p>(fonctions de la famille des <code>apply</code> = boucles, pas calcul vectoriel)</p>
</div>
<div id="astuce-4-éviter-les-allocations-de-mémoire-inutiles-1" class="section level5">
<h5>Astuce 4 : Éviter les allocations de mémoire inutiles</h5>

<p>Allouer de l’espace dans la mémoire d’un ordinateur = opération coûteuse en temps</p>
<p>Opérations à éviter dans une boucle R :</p>
<ol style="list-style-type: decimal">
<li>utilisation d’un objet de dimension croissante : utiliser plutôt un objet de taille fixe;</li>
<li>assignation de valeur(s) dans un data frame : utiliser plutôt un objet atomique ou un data table.</li>
</ol>
</div>
<div id="astuce-5-faire-du-calcul-en-parallèle-1" class="section level5">
<h5>Astuce 5 : Faire du calcul en parallèle</h5>

<p>Version la plus simple du calcul en parallèle :</p>
<ul>
<li>brise un long calcul en petits blocs de calcul indépendants;</li>
<li>réalise ces blocs de calcul sur plusieurs unités de calcul (coeurs d’un processeur) simultanément (donc en parallèle);</li>
<li>rassemble à la fin tous les résultats.</li>
</ul>
<p>Domaine très large : <a href="https://cran.r-project.org/web/views/HighPerformanceComputing.html" class="uri">https://cran.r-project.org/web/views/HighPerformanceComputing.html</a></p>
<p>Domaine très technique : dépend des ressources à notre portée (CPU versus GPU, plusieurs coeurs sur notre ordinateur, grappe de serveurs de calcul, plateforme de cloud computing, etc.)</p>
<p>Point de départ en R : package <code>parallel</code></p>
</div>
<div id="astuce-6-reprogrammer-en-c-ou-c-les-bouts-de-code-les-plus-lents-1" class="section level5">
<h5>Astuce 6 : Reprogrammer en C ou C++ les bouts de code les plus lents</h5>

<p>Meilleure solution pour développer une fonction très rapide, pas pour réaliser rapidement des analyses de données.</p>
<ul>
<li>fonction d’interface <code>.C</code>,</li>
<li>fonction d’interface <code>.Call</code> ou <code>.External</code>,</li>
<li>package <code>Rcpp</code> pour l’intégration de code C++.</li>
</ul>
<hr />
</div>
</div>
</div>
<div id="références" class="section level1">
<h1>Références</h1>
<ul>
<li><strong>Outils d’analyse de la performance d’un programme R</strong>
<ul>
<li>Hester, J. (2020). <code>bench</code>: <em>High Precision Timing of R Expressions</em>. R package version 1.1.1. URL
<a href="https://CRAN.R-project.org/package=bench" class="uri">https://CRAN.R-project.org/package=bench</a>
<ul>
<li>URL documentation en ligne <a href="http://bench.r-lib.org/" class="uri">http://bench.r-lib.org/</a></li>
</ul></li>
<li>Chang, W., Luraschi, J. et Mastny, T. (2019). <code>profvis</code>: <em>Interactive Visualizations for Profiling R Code</em>. R package version 0.3.6. URL <a href="https://CRAN.R-project.org/package=profvis" class="uri">https://CRAN.R-project.org/package=profvis</a>
<ul>
<li>URL documentation en ligne <a href="https://rstudio.github.io/profvis/" class="uri">https://rstudio.github.io/profvis/</a><br />
</li>
</ul></li>
</ul></li>
<li><strong>Optimisation de temps d’exécution</strong>
<ul>
<li>Wickham, H. (2019). <em>Advanced R, Second Edition</em>. Chapman and Hall/CRC.
<ul>
<li>Chapitre 2 <em>Names and values</em>, URL <a href="https://adv-r.hadley.nz/names-values.html" class="uri">https://adv-r.hadley.nz/names-values.html</a></li>
<li>Chapitre 23 <em>Measuring performance</em>, URL <a href="https://adv-r.hadley.nz/perf-measure.html" class="uri">https://adv-r.hadley.nz/perf-measure.html</a></li>
<li>Chapitre 24 <em>Improving performance</em>, URL <a href="https://adv-r.hadley.nz/perf-improve.html" class="uri">https://adv-r.hadley.nz/perf-improve.html</a></li>
</ul></li>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design</em>, No Starch Press. Chapitre 14.</li>
<li>Ross, N. (2014). Tutoriel web intitulé « Vectorization in R: Why? »<br />
URL <a href="http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html" class="uri">http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html</a></li>
<li>Adler, J. (2012). <em>R in a Nutshell</em>, Second edition. O’Reilly. Chapitre 24.<br />
</li>
</ul></li>
<li><strong>Interfacer du code dans un autre langage (en particulier C ou C++)</strong>
<ul>
<li>Peng, R. D., &amp; de Leeuw, J. (2002). An Introduction to the .C Interface to R. UCLA: Academic Technology Services, Statistical Consulting Group. URL <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf" class="uri">http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf</a></li>
<li>R Core Team (2020). <em>Writing R Extensions</em>. R Foundation for Statistical Computing. Chapitre 5. URL <a href="http://cran.r-project.org/doc/manuals/r-release/R-exts.html#System-and-foreign-language-interfaces" class="uri">http://cran.r-project.org/doc/manuals/r-release/R-exts.html#System-and-foreign-language-interfaces</a></li>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design</em>, No Starch Press. Chapitre 15.</li>
<li>Utilisation du package <code>Rcpp</code> :
<ul>
<li><a href="http://www.rcpp.org/" class="uri">http://www.rcpp.org/</a></li>
<li>Wickham, H. (2019). <em>Advanced R, Second Edition</em>. Chapman and Hall/CRC. Chapitre 19. <em>Rewriting R code in C++</em> URL <a href="https://adv-r.hadley.nz/rcpp.html" class="uri">https://adv-r.hadley.nz/rcpp.html</a><br />
</li>
</ul></li>
</ul></li>
<li><strong>Calcul en parallèle</strong>
<ul>
<li>Baillargeon, S. (2017). Tutoriel intitulé « Calcul en parallèle sur CPU avec R ». URL <a href="https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/" class="uri">https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/</a></li>
<li>McCallum, E., &amp; Weston, S. (2011). <em>Parallel R</em>. O’Reilly.</li>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design, No Starch Press</em>. Chapitre 16.</li>
</ul></li>
</ul>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Cet exemple était tiré de Matloff, N. (2011). The Art of R Programming : A Tour of Statistical Software Design. No Starch Press. Sections 1.3 et 7.4.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>
