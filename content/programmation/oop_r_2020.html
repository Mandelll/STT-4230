---
title: "Programmation orientée objet en R"
author: "Sophie Baillargeon, Université Laval"
date: "2020-03-13"
weight: 4
slug: "oop_r"
categories: ["cours_2020-03-24"]
categories_weight: 1
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    highlight: tango
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    highlight: tango
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
- \renewcommand{\linethickness}{0.05em}
editor_options: 
  chunk_output_type: console
---





<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { background-color: #f8f8f8; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#système-s3">Système S3</a><ul>
<li><a href="#fonctionnement-du-système-s3">Fonctionnement du système S3</a><ul>
<li><a href="#situation-particulière-1-lobjet-assigné-au-premier-argument-na-pas-dattribut-class">Situation particulière 1 : l’objet assigné au premier argument n’a pas d’attribut <code>"class"</code></a></li>
<li><a href="#situation-particulière-2-la-méthode-nom_fonction_generique.nom_classe-nexiste-pas">Situation particulière 2 : la méthode <code>nom_fonction_generique.nom_classe</code> n’existe pas</a></li>
<li><a href="#situation-particulière-3-class-retourne-plus-dune-classe">Situation particulière 3 : <code>class</code> retourne plus d’une classe</a></li>
<li><a href="#situation-particulière-4-la-fonction-générique-possède-plus-dun-argument">Situation particulière 4 : la fonction générique possède plus d’un argument</a></li>
</ul></li>
<li><a href="#création-de-classes-et-de-méthodes-de-type-s3">Création de classes et de méthodes de type S3</a><ul>
<li><a href="#assignation-dune-classe-à-un-objet">Assignation d’une classe à un objet</a></li>
<li><a href="#conception-dune-méthode-pour-une-classe">Conception d’une méthode pour une classe</a></li>
<li><a href="#méthode-print-pour-formater-limpression-des-sorties-de-nos-fonctions">Méthode <code>print</code> pour formater l’impression des sorties de nos fonctions</a></li>
</ul></li>
</ul></li>
<li><a href="#système-s4">Système S4</a><ul>
<li><a href="#manipulation-dobjets-dont-la-classe-est-de-type-s4">Manipulation d’objets dont la classe est de type S4</a></li>
</ul></li>
<li><a href="#résumé">Résumé</a></li>
<li><a href="#références">Références</a></li>
</ul>
</div>

<hr />
<p>La programmation orientée objet est un paradigme de programmation basé sur le concept d’objets, qui peuvent contenir des données et métadonnées (attributs), et qui sont associés à des procédures, souvent appelées méthodes. R propose plusieurs systèmes orientés objet en R :</p>
<ul>
<li><strong>S3</strong> : Il s’agit du système le moins formel, mais le plus utilisé, en particulier dans les packages <code>base</code> et <code>stats</code>. Ces notes traitent principalement de ce système.</li>
<li><strong>S4</strong> : Ce système fonctionne de façon similaire au système S3, mais il est plus formel. La majorité des packages sur <a href="https://www.bioconductor.org/">Bioconductor</a> utilisent ce système. Nous verrons ici comment manipuler des objets dont la classe est de type S4, mais pas comment en créer.</li>
<li>Autres : Parmi les autres systèmes orientés objet en R, il y a eu <a href="http://adv-r.had.co.nz/R5.html"><strong>RC</strong> (aussi nommé <strong>R5</strong>), le système « Reference Classes »</a>. Celui-ci n’a cependant jamais été très utilisé. Récemment, le <a href="https://adv-r.hadley.nz/r6.html">système <strong>R6</strong></a> a vu le jour, afin de remplacer le système RC. Comparativement aux systèmes S3 et S4, ce système se rapproche davantage du paradigme orienté objet des langages informatiques Python et Java notamment. Comparativement au système RC, il est plus simple et plus rapide. Ces autres systèmes ne seront pas approfondis dans ce cours.</li>
</ul>
<div id="système-s3" class="section level1">
<h1>Système S3</h1>
<p>À chaque fois que nous avons effleuré le sujet de la programmation orientée objet dans ce cours, nous parlions toujours du système S3. Nous l’avons mentionné dans les notes sur :</p>
<ul>
<li>les concepts de base, à la section « <a href="https://stt4230.rbind.io/introduction/base_r/#est-ce-que-de-la-programmation-orient%C3%A9e-objet-est-possible-en-r">Est-ce que de la programmation orientée objet est possible en R ?</a> »;</li>
<li>les graphiques, à la section « <a href="https://stt4230.rbind.io/communication_resultats/graphiques_r/#fonction-g%C3%A9n%C3%A9rique-plot">Fonction générique plot</a> »;</li>
<li>les calculs statistiques et mathématiques, à la section« <a href="https://stt4230.rbind.io/calculs/calculs_stat_math_r/#manipulation-de-la-sortie-dune-fonction-dajustement-de-mod%C3%A8le">Manipulation de la sortie d’une fonction d’ajustement de modèle</a> ».</li>
</ul>
<p>Le fonctionnement de ce système est très simple. Il est possible d’attribuer des <em>classes</em> de type S3 aux objets R. Ces classes déterminent comment les <em>fonctions génériques</em> se comportent en recevant en entrée un certain objet. Une fonction générique est dite <em>polymorphe</em>. Elle possède plusieurs définitions, appelées <em>méthodes</em>, pour des objets de différentes classes. Techniquement, une fonction générique R ne fait que rediriger les arguments qui lui sont fournis en entrée vers la méthode associée à la classe de l’objet assigné à son premier argument.</p>
<p>Voyons plus en détail le fonctionnement du système S3, puis apprenons comment créer une nouvelle méthode pour une fonction générique existante. Nous ne verrons pas comment créer de nouvelles fonctions génériques.</p>
<div id="fonctionnement-du-système-s3" class="section level2">
<h2>Fonctionnement du système S3</h2>
<p>Nous avons déjà mentionné que les fonctions suivantes sont génériques : <code>plot</code>, <code>print</code>, <code>summary</code>, <code>coef</code> et plusieurs autres fonctions d’extraction d’informations de la sortie d’une fonction d’ajustement de modèle. La <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/print.html">fonction <code>print</code></a> est probablement la fonction de cette liste que nous utilisons le plus souvent, puisqu’elle est appelée à chaque fois que nous soumettons dans la console une commande contenant uniquement le nom d’un objet. La définition de cette fonction est la suivante :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1">print</a></code></pre></div>
<pre><code>## function (x, ...) 
## UseMethod(&quot;print&quot;)
## &lt;bytecode: 0x000000001446e658&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>Il n’y a qu’une seule instruction dans le corps de cette fonction : un appel à la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/UseMethod.html">fonction <code>UseMethod</code></a>. Toutes les fonctions génériques ont cette forme. De plus, la plupart d’entre elles possèdent un argument « <code>...</code> ».</p>
<p>Lorsqu’une fonction générique est appelée, la fonction <code>UseMethod</code> vérifie d’abord la classe de l’objet fourni au premier argument, ici <code>x</code>. Ensuite, elle appelle la méthode correspondant à la classe obtenue, si elle existe, en lui fournissant en entrée les arguments qui ont été fournis dans l’appel à la fonction générique.</p>
<p>Par exemple, considérons le data frame suivant (il s’agit d’un jeu de données du package <code>datasets</code>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">str</span>(women)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    15 obs. of  2 variables:
##  $ height: num  58 59 60 61 62 63 64 65 66 67 ...
##  $ weight: num  115 117 120 123 126 129 132 135 139 142 ...</code></pre>
<p>Les data frames possèdent un attribut <code>class</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">attributes</span>(women)</a></code></pre></div>
<pre><code>## $names
## [1] &quot;height&quot; &quot;weight&quot;
## 
## $class
## [1] &quot;data.frame&quot;
## 
## $row.names
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<p>Lors de l’évaluation de l’appel à la fonction <code>print</code> suivant :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">print</span>(women)</a></code></pre></div>
<p>R va d’abord vérifier la classe de l’objet assigné au premier argument dans l’appel de la fonction :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span>(women)</a></code></pre></div>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>Puis R va vérifier si une méthode <code>print</code> est définie pour cette classe. La <a href="https://stat.ethz.ch/R-manual/R-patched/library/utils/html/methods.html">fonction <code>methods</code></a> nous permet de connaître toutes les méthodes définies pour une fonction générique présente dans le chemin de recherche de notre session R.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">methods</span>(print)</a></code></pre></div>
<p>Le résultat n’est pas affiché en entier, car le nombre de méthodes pour la fonction générique <code>print</code> est trop grand. Voici cependant un extrait de la sortie que j’obtiens.</p>
<pre><code>## . . .
## [67] print.condition                                    print.connection  
## [69] print.CRAN_package_reverse_dependencies_and_views* print.data.frame
## [71] print.Date                                         print.default
## [73] print.dendrogram*                                  print.density* 
## . . .
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>Pour une classe spécifique, une méthode de type S3 portera le nom : <code>nom_fonction_generique.nom_classe</code>. Nous voyons ici que la méthode <code>print.data.frame</code> existe. Celle-ci est une fonction, dont la définition est la suivante :</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">print.data.frame</a></code></pre></div>
<pre><code>## function (x, ..., digits = NULL, quote = FALSE, right = TRUE, 
##     row.names = TRUE, max = NULL) 
## {
##     n &lt;- length(row.names(x))
##     if (length(x) == 0L) {
##         cat(sprintf(ngettext(n, &quot;data frame with 0 columns and %d row&quot;, 
##             &quot;data frame with 0 columns and %d rows&quot;), n), &quot;\n&quot;, 
##             sep = &quot;&quot;)
##     }
##     else if (n == 0L) {
##         print.default(names(x), quote = FALSE)
##         cat(gettext(&quot;&lt;0 rows&gt; (or 0-length row.names)\n&quot;))
##     }
##     else {
##         if (is.null(max)) 
##             max &lt;- getOption(&quot;max.print&quot;, 99999L)
##         if (!is.finite(max)) 
##             stop(&quot;invalid &#39;max&#39; / getOption(\&quot;max.print\&quot;): &quot;, 
##                 max)
##         omit &lt;- (n0 &lt;- max%/%length(x)) &lt; n
##         m &lt;- as.matrix(format.data.frame(if (omit) 
##             x[seq_len(n0), , drop = FALSE]
##         else x, digits = digits, na.encode = FALSE))
##         if (!isTRUE(row.names)) 
##             dimnames(m)[[1L]] &lt;- if (isFALSE(row.names)) 
##                 rep.int(&quot;&quot;, if (omit) 
##                   n0
##                 else n)
##             else row.names
##         print(m, ..., quote = quote, right = right, max = max)
##         if (omit) 
##             cat(&quot; [ reached &#39;max&#39; / getOption(\&quot;max.print\&quot;) -- omitted&quot;, 
##                 n - n0, &quot;rows ]\n&quot;)
##     }
##     invisible(x)
## }
## &lt;bytecode: 0x0000000014351860&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>R va donc finalement appeler cette fonction.</p>
<p>Donc, la commande</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1">women</a></code></pre></div>
<p>qui revient en fait à la commande</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">print</span>(women)</a></code></pre></div>
<p>cache l’évaluation de la commande suivante</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">print.data.frame</span>(women)</a></code></pre></div>
<p>qui produit le résultat suivant.</p>
<pre><code>##    height weight
## 1      58    115
## 2      59    117
## 3      60    120
## 4      61    123
## 5      62    126
## 6      63    129
## 7      64    132
## 8      65    135
## 9      66    139
## 10     67    142
## 11     68    146
## 12     69    150
## 13     70    154
## 14     71    159
## 15     72    164</code></pre>
<div id="situation-particulière-1-lobjet-assigné-au-premier-argument-na-pas-dattribut-class" class="section level3">
<h3>Situation particulière 1 : l’objet assigné au premier argument n’a pas d’attribut <code>"class"</code></h3>
<p>Dans l’exemple précédent, l’objet fourni en entrée au premier argument de la fonction générique possédait un argument nommé <code>"class"</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">attr</span>(women, <span class="dt">which =</span> <span class="st">&quot;class&quot;</span>)</a></code></pre></div>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>Qu’arrive-t-il si l’objet assigné au premier argument n’a pas d’attribut <code>"class"</code> ?</p>
<p>En toute circonstance, la fonction <code>class</code> doit retourner une classe pour permettre en système S3 de bien fonctionner. Alors les objets R ont tous une classe implicite.</p>
<p>Par exemple, créons une copie de <code>women</code> pour laquelle nous allons retirer l’attribut <code>class</code> avec la fonction <code>unclass</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1">women_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">unclass</span>(women)</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">attr</span>(women_<span class="dv">2</span>, <span class="dt">which =</span> <span class="st">&quot;class&quot;</span>)</a></code></pre></div>
<pre><code>## NULL</code></pre>
<p>L’objet <code>women_2</code> n’a pas d’attribut <code>class</code>, mais il possède tout de même une classe implicite.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">class</span>(women_<span class="dv">2</span>)</a></code></pre></div>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p>L’objet <code>women_2</code> possède la classe implicite <code>"list"</code>. Ce résultat est cohérent avec le fait qu’un data frame est un type particulier de liste.</p>
<p>Bref, la fonction <code>class</code> fonctionne comme suit. Elle vérifie d’abord si l’objet qu’elle reçoit en entrée possède une classe explicite, soit un attribut nommé <code>"class"</code>. Si c’est le cas, elle retourne cet attribut. Sinon, elle retourne la classe implicite de l’objet.</p>
<div id="remarque" class="section level4">
<h4>Remarque</h4>

<p>Notons que, alors que les listes ont la classe implicite <code>list</code>, les arrays ont la classe implicite <code>array</code>, les matrices ont la classe implicite <code>matrix</code> et les vecteurs ont une classe implicite correspondant au type de données qu’ils contiennent, par exemple :</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" title="1">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb24-2" title="2">x</a></code></pre></div>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">class</span>(x)</a></code></pre></div>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p>Les facteurs, pour leur part, ont un attribut <code>class</code>, tout comme les data frames.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1">x_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(x)</a>
<a class="sourceLine" id="cb28-2" title="2">x_factor</a></code></pre></div>
<pre><code>## [1] 1 2 3 4 5
## Levels: 1 2 3 4 5</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">attributes</span>(x_factor)</a></code></pre></div>
<pre><code>## $levels
## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot;
## 
## $class
## [1] &quot;factor&quot;</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">class</span>(x_factor)</a></code></pre></div>
<pre><code>## [1] &quot;factor&quot;</code></pre>
</div>
</div>
<div id="situation-particulière-2-la-méthode-nom_fonction_generique.nom_classe-nexiste-pas" class="section level3">
<h3>Situation particulière 2 : la méthode <code>nom_fonction_generique.nom_classe</code> n’existe pas</h3>
<p>Qu’arrive-t-il si la fonction générique <code>nom_fonction_generique</code> reçoit comme premier argument en entrée un objet de classe <code>nom_classe</code>, mais que la méthode <code>nom_fonction_generique.nom_classe</code> n’existe pas ?</p>
<p>Dans ce cas, R utilise la méthode par défaut, si elle existe, sinon il retourne une erreur. La méthode par défaut d’une fonction générique se nomme toujours <code>nom_fonction_generique.default</code>, où <code>nom_fonction_generique</code> est le nom de la fonction générique.</p>
<p>Par exemple, reprenons l’objet <code>women_2</code> de classe implicite <code>"list"</code>. Comment agit la fonction générique <code>print</code> avec cet objet ?</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">print</span>(women_<span class="dv">2</span>)</a></code></pre></div>
<pre><code>## $height
##  [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72
## 
## $weight
##  [1] 115 117 120 123 126 129 132 135 139 142 146 150 154 159 164
## 
## attr(,&quot;row.names&quot;)
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<p>Lors de l’évaluation de la commande <code>print(women_2)</code>, R cherche d’abord à appeler la méthode <code>print.list</code>, mais celle-ci n’existe pas.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">any</span>(<span class="kw">methods</span>(print) <span class="op">==</span><span class="st"> &quot;print.list&quot;</span>)</a></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Il se rabat donc sur la méthode <code>print</code> par défaut et évalue l’appel de fonction suivant :</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">print.default</span>(women_<span class="dv">2</span>)</a></code></pre></div>
<pre><code>## $height
##  [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72
## 
## $weight
##  [1] 115 117 120 123 126 129 132 135 139 142 146 150 154 159 164
## 
## attr(,&quot;row.names&quot;)
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<p>Cependant, certaines fonctions génériques ne possèdent pas de méthode par défaut. Par exemple, c’est le cas de la fonction générique <code>anova</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">methods</span>(anova)</a></code></pre></div>
<pre><code>## [1] anova.glm*     anova.glmlist* anova.lm*      anova.lmlist*  anova.loess*  
## [6] anova.mlm*     anova.nls*    
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>Si nous donnons en entrée à la fonction <code>anova</code> un objet qui n’est pas de classe <code>glm</code>, <code>glmlist</code>, <code>lm</code>, <code>lmlist</code>, <code>loess</code>, <code>mlm</code> ou <code>nls</code>, une erreur est retournée.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">anova</span>(women_<span class="dv">2</span>)</a></code></pre></div>
<pre><code>## Error in UseMethod(&quot;anova&quot;) : 
##   no applicable method for &#39;anova&#39; applied to an object of class &quot;list&quot;</code></pre>
<div id="remarque-1" class="section level4">
<h4>Remarque</h4>

<p>Notons que la fonction <code>methods</code> permet aussi d’énumérer les fonctions génériques possédant une méthode associée à une classe en particulier. Par exemple, les méthodes associées à la classe <code>lm</code> présentes dans le chemin de recherche de ma session R sont les suivantes :</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" title="1"><span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&quot;lm&quot;</span>)</a></code></pre></div>
<pre><code>##  [1] add1           alias          anova          case.names     coerce        
##  [6] confint        cooks.distance deviance       dfbeta         dfbetas       
## [11] drop1          dummy.coef     effects        extractAIC     family        
## [16] formula        hatvalues      influence      initialize     kappa         
## [21] labels         logLik         model.frame    model.matrix   nobs          
## [26] plot           predict        print          proj           qr            
## [31] residuals      rstandard      rstudent       show           simulate      
## [36] slotsFromS3    summary        variable.names vcov          
## see &#39;?methods&#39; for accessing help and source code</code></pre>
</div>
</div>
<div id="situation-particulière-3-class-retourne-plus-dune-classe" class="section level3">
<h3>Situation particulière 3 : <code>class</code> retourne plus d’une classe</h3>
<p>Les objets R peuvent posséder plus d’une classe. Par exemple, les objets R retournés par la fonction <code>aov</code> ont deux classes : <code>aov</code> et <code>lm</code>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" title="1">model &lt;-<span class="st"> </span><span class="kw">aov</span>(Sepal.Length <span class="op">~</span><span class="st"> </span>Species, <span class="dt">data =</span> iris)</a>
<a class="sourceLine" id="cb46-2" title="2"><span class="kw">class</span>(model)</a></code></pre></div>
<pre><code>## [1] &quot;aov&quot; &quot;lm&quot;</code></pre>
<p>Qu’arrive-t-il lorsque <code>class</code> retourne plus d’une classe ?</p>
<p>Si un objet possédant plus d’une classe est fourni en entrée à une fonction générique, R cherche d’abord à utiliser la méthode associée à la première classe de la liste. Si celle-ci n’existe pas, R utilise la méthode associée à le seconde classe. Si celle-ci n’existe pas, R continue à parcourir le vecteur des noms de classe jusqu’à ce qu’il trouve une méthode pour une classe. S’il n’existe de méthode pour aucune classe de la liste, c’est la méthode par défaut qui est employée, si elle existe, sinon une erreur est générée, comme nous venons de le voir.</p>
</div>
<div id="situation-particulière-4-la-fonction-générique-possède-plus-dun-argument" class="section level3">
<h3>Situation particulière 4 : la fonction générique possède plus d’un argument</h3>
<p>Certaines fonctions génériques, telle que la fonction <code>plot</code>, possèdent plus d’un argument.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" title="1">plot</a></code></pre></div>
<pre><code>## function (x, y, ...) 
## UseMethod(&quot;plot&quot;)
## &lt;bytecode: 0x00000000142ee688&gt;
## &lt;environment: namespace:graphics&gt;</code></pre>
<p>Quel impact ont ces autres arguments sur le choix de la méthode à utiliser ?</p>
<p>Ils n’ont aucun impact sur le choix de la méthode. Cette méthode peut cependant utiliser ces autres arguments pour déterminer ce qu’elle va faire. Par exemple, le corps de la méthode <code>plot.factor</code> contient une série de <code>if</code> … <code>else</code> qui servent à sélectionner la fonction graphique à appeler en fonction des caractéristiques de l’objet assigné au deuxième argument, soit <code>y</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" title="1">graphics<span class="op">:::</span>plot.factor</a></code></pre></div>
<pre><code>## function (x, y, legend.text = NULL, ...) 
## {
##     if (missing(y) || is.factor(y)) {
##         dargs &lt;- list(...)
##         axisnames &lt;- if (!is.null(dargs$axes)) 
##             dargs$axes
##         else if (!is.null(dargs$xaxt)) 
##             dargs$xaxt != &quot;n&quot;
##         else TRUE
##     }
##     if (missing(y)) {
##         barplot(table(x), axisnames = axisnames, ...)
##     }
##     else if (is.factor(y)) {
##         if (is.null(legend.text)) 
##             spineplot(x, y, ...)
##         else {
##             args &lt;- c(list(x = x, y = y), list(...))
##             args$yaxlabels &lt;- legend.text
##             do.call(&quot;spineplot&quot;, args)
##         }
##     }
##     else if (is.numeric(y)) 
##         boxplot(y ~ x, ...)
##     else NextMethod(&quot;plot&quot;)
## }
## &lt;bytecode: 0x000000001af8cf08&gt;
## &lt;environment: namespace:graphics&gt;</code></pre>
</div>
</div>
<div id="création-de-classes-et-de-méthodes-de-type-s3" class="section level2">
<h2>Création de classes et de méthodes de type S3</h2>
<p>Il est facile de créer de nouvelles méthodes pour des fonctions génériques existantes, telles que <code>print</code>, <code>plot</code> et <code>summary</code>. Par exemple, supposons que nous voulons modifier l’impression de l’objet suivant.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" title="1">valeurs_aleatoires &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb52-2" title="2"><span class="kw">print</span>(valeurs_aleatoires)</a></code></pre></div>
<pre><code>## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424</code></pre>
<p>Cet objet a la classe implicite suivante.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">class</span>(valeurs_aleatoires)</a></code></pre></div>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>Est-ce qu’une méthode de la fonction générique <code>print</code> existe pour cette classe ?</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&quot;numeric&quot;</span>)</a></code></pre></div>
<pre><code>## [1] all.equal     as.data.frame as.Date       as.POSIXct    as.POSIXlt   
## [6] as.raster     coerce        Ops          
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">any</span>(<span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&quot;numeric&quot;</span>) <span class="op">==</span><span class="st"> &quot;print.numeric&quot;</span>)</a></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Non. Ainsi, l’impression produite par la commande <code>print(valeurs_aleatoires)</code> provient d’un appel à la méthode <code>print.default</code>.</p>
<p>Pour modifier l’impression de l’objet <code>valeurs_aleatoires</code>, nous pourrions créer une méthode <code>print</code> pour la classe <code>"numeric"</code>. Cette façon de faire fonctionnerait, mais est-ce une bonne idée ?</p>
<p>Non. Procéder de cette façon aurait un désavantage majeur : l’impression de tous les objets de classe <code>"numeric"</code> serait modifiée. Nous ne souhaitons pas changer le comportement général de R avec les objets de classe <code>"numeric"</code>. Nous souhaitons changer l’impression d’un seul objet : <code>valeurs_aleatoires</code>.</p>
<p>Il est donc préférable d’assigner une toute nouvelle classe à l’objet <code>valeurs_aleatoires</code>, puis d’écrire une méthode <code>print</code> pour cette classe.</p>
<div id="assignation-dune-classe-à-un-objet" class="section level3">
<h3>Assignation d’une classe à un objet</h3>
<p>Pour assigner une classe à un objet R, il suffit de l’encadrer d’un appel à la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html">fonction <code>class</code></a>, suivi d’un opérateur d’assignation et du nom de la classe sous forme de chaîne de caractère. Un nom de classe ne doit pas comporter d’espaces. Voici un exemple avec l’objet <code>valeurs_aleatoires</code>.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">class</span>(valeurs_aleatoires) &lt;-<span class="st"> &quot;mon_vecteur&quot;</span></a>
<a class="sourceLine" id="cb60-2" title="2"><span class="kw">print</span>(valeurs_aleatoires)</a></code></pre></div>
<pre><code>## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424
## attr(,&quot;class&quot;)
## [1] &quot;mon_vecteur&quot;</code></pre>
</div>
<div id="conception-dune-méthode-pour-une-classe" class="section level3">
<h3>Conception d’une méthode pour une classe</h3>
<p>Les méthodes sont des fonctions. Alors créer une méthode signifie simplement créer une fonction. C’est le nom d’une fonction qui détermine si elle est une simple fonction ou une méthode associée à une fonction générique.</p>
<p>Une fonction dont le nom est de la forme <code>nom_fonction_generique.nom_classe</code> est une méthode associée à la fonction générique nommée <code>nom_fonction_generique</code>, pour la classe nommée <code>nom_classe</code>. Il faut évidemment que <code>nom_fonction_generique</code> soit le nom d’une fonction générique. La fonction <code>data.frame</code> n’est pas une méthode associée à la fonction générique <code>data</code> pour la classe <code>frame</code>. Alors la simple présence d’un point dans le nom d’une fonction n’implique pas nécessairement qu’il s’agisse d’une méthode de type S3.</p>
<p>Une méthode comporte typiquement les arguments suivants :</p>
<ul>
<li>même premier argument que la fonction générique (portant idéalement le même nom)</li>
<li>autres arguments de la fonction générique, au besoin;</li>
<li>arguments supplémentaires, au besoin;</li>
<li>l’argument <code>...</code> (même s’il n’est pas utilisé).</li>
</ul>
<p>Il est important que le premier argument de la méthode concorde avec le premier argument de la fonction générique, car lorsque la fonction générique appellera la méthode, elle assignera comme valeur à son premier argument ce qu’elle a reçu comme valeur pour son propre premier argument.</p>
<p>L’ordre des autres arguments n’est cependant pas tellement important. Par exemple, la fonction générique <code>aggregate</code> possède 2 arguments : <code>x</code> et <code>...</code> :</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" title="1">aggregate</a></code></pre></div>
<pre><code>## function (x, ...) 
## UseMethod(&quot;aggregate&quot;)
## &lt;bytecode: 0x0000000013863358&gt;
## &lt;environment: namespace:stats&gt;</code></pre>
<p>Il existe 4 méthodes pour cette fonction générique dans l’installation de base de R :</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">methods</span>(aggregate)</a></code></pre></div>
<pre><code>## [1] aggregate.data.frame aggregate.default*   aggregate.formula*   aggregate.ts        
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>Ces méthodes possèdent les arguments suivants :</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" title="1"><span class="kw">args</span>(aggregate.data.frame)</a></code></pre></div>
<pre><code>## function (x, by, FUN, ..., simplify = TRUE, drop = TRUE) 
## NULL</code></pre>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" title="1"><span class="kw">args</span>(<span class="kw">getS3method</span>(<span class="st">&quot;aggregate&quot;</span>, <span class="st">&quot;default&quot;</span>))</a></code></pre></div>
<pre><code>## function (x, ...) 
## NULL</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" title="1"><span class="kw">args</span>(<span class="kw">getS3method</span>(<span class="st">&quot;aggregate&quot;</span>, <span class="st">&quot;formula&quot;</span>))</a></code></pre></div>
<pre><code>## function (formula, data, FUN, ..., subset, na.action = na.omit) 
## NULL</code></pre>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" title="1"><span class="kw">args</span>(aggregate.ts)</a></code></pre></div>
<pre><code>## function (x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption(&quot;ts.eps&quot;), 
##     ...) 
## NULL</code></pre>
<p>L’argument <code>...</code> est toujours présent, mais il n’est pas toujours placé en dernier. La méthode <code>aggregate.default</code> ne possède pas d’arguments supplémentaires, contrairement aux autres méthodes. De plus, une de ces méthodes (<code>aggregate.formula</code>) ne possède même pas d’argument nommé <code>x</code>.</p>
<div id="exemple-avec-la-méthode-générique-print" class="section level4">
<h4>Exemple avec la méthode générique <code>print</code></h4>

<p>Créons une méthode <code>print</code> pour la classe <code>mon_vecteur</code>.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb74-1" title="1">print.mon_vecteur &lt;-<span class="st"> </span><span class="cf">function</span>(x, ..., <span class="dt">intro =</span> <span class="ot">TRUE</span>) {</a>
<a class="sourceLine" id="cb74-2" title="2">  <span class="cf">if</span> (intro) {</a>
<a class="sourceLine" id="cb74-3" title="3">    <span class="kw">cat</span>(<span class="st">&quot;Voici le vecteur :</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb74-4" title="4">  }</a>
<a class="sourceLine" id="cb74-5" title="5">  <span class="kw">print</span>(<span class="kw">unclass</span>(x), ...)</a>
<a class="sourceLine" id="cb74-6" title="6">  <span class="kw">invisible</span>(x)</a>
<a class="sourceLine" id="cb74-7" title="7">}</a></code></pre></div>
<p>Voyons l’impression produit par notre nouvelle méthode.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" title="1"><span class="kw">print</span>(valeurs_aleatoires)</a></code></pre></div>
<pre><code>## Voici le vecteur :
## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" title="1"><span class="kw">print</span>(valeurs_aleatoires, <span class="dt">intro =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424</code></pre>
<div id="utilité-de-lappel-à-la-fonction-unclass" class="section level5">
<h5>Utilité de l’appel à la fonction <code>unclass</code></h5>

<p>Vous remarquerez que le corps de la méthode <code>print.mon_vecteur</code> comporte un appel à la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html">fonction <code>unclass</code></a> dans l’instruction <code>print(unclass(x), ...)</code>. L’appel à <code>unclass</code> est important. Sans lui, une boucle sans fin serait exécutée lors de l’appel de la fonction <code>print</code> en lui donnant un objet de classe <code>mon_vecteur</code> en entrée : la fonction générique <code>print</code> appellerait la méthode <code>print.mon_vecteur</code>, qui appellerait la fonction générique <code>print</code>, qui appellerait la méthode <code>print.mon_vecteur</code> et ainsi de suite.</p>
<p>L’appel à la fonction <code>unclass</code> dans <code>print(unclass(x), ...)</code> permet de fournir en entrée à <code>print</code> l’objet <code>x</code> sans sont attribut <code>"class"</code>. Ainsi, <code>print</code> appellera la méthode correspondant à la classe implicite de <code>x</code>.</p>
</div>
<div id="impact-du-positionnement-de-largument-..." class="section level5">
<h5>Impact du positionnement de l’argument <code>...</code></h5>

<p>Dans cet exemple, nous avons placé l’argument <code>...</code> avant les arguments supplémentaires dans la déclaration de la méthode. Dans le corps de la fonction, nous avons passé l’argument <code>...</code> à un appel à la fonction <code>print</code>. En conséquence, si nous appelons <code>print.mon_vecteur</code> (via <code>print</code> ou non) en passant une deuxième valeur sans l’assigner à un nom d’argument, cette valeur sera automatiquement assignée au deuxième argument de la méthode <code>print</code> appelée et non à l’argument <code>intro</code> de la méthode <code>print.mon_vecteur</code>.</p>
<p>Voici un exemple.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" title="1"><span class="kw">print</span>(valeurs_aleatoires, <span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>## Voici le vecteur :
## [1]  0  0 -1 -0 -0 -1  0</code></pre>
<p>Ici, <code>print</code> appelle sa méthode <code>print.mon_vecteur</code>, qui appelle de nouveau la méthode <code>print</code>, qui choisit d’appeler sa méthode <code>print.default</code> (car <code>class(unclass(valeurs_aleatoires))</code> retourne <code>"numeric"</code> et <code>print.numeric</code> n’existe pas). Le deuxième argument de <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/print.default.html"><code>print.default</code></a> est <code>digits</code>. Il reçoit la valeur <code>FALSE</code>, qui est alors transformée en la valeur numérique 0 et les nombres affichés sont arrondis à l’unité près.</p>
</div>
<div id="utilité-de-lappel-à-la-fonction-invisible" class="section level5">
<h5>Utilité de l’appel à la fonction <code>invisible</code></h5>

<p>Il est courant pour une méthode <code>print</code> de terminer par la commande <code>invisible(x)</code>. La <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/invisible.html">fonction <code>invisible</code></a> provoque le retour d’une valeur par la fonction, tout comme la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/function.html">fonction <code>return</code></a>. Cependant, contrairement à <code>return</code>, <code>invisible</code> ne provoque pas une impression lorsque l’appel de la fonction n’est pas assigné à un nom, évitant ainsi une impression double suite à une commande comme la suivante :</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb81-1" title="1"><span class="kw">print</span>(valeurs_aleatoires)</a></code></pre></div>
<pre><code>## Voici le vecteur :
## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424</code></pre>
<p>Si <code>invisible</code> était remplacé par <code>return</code> dans le corps de la méthode <code>print.mon_vecteur</code> comme suit</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb83-1" title="1">print.mon_vecteur &lt;-<span class="st"> </span><span class="cf">function</span>(x, ..., <span class="dt">intro =</span> <span class="ot">TRUE</span>) {</a>
<a class="sourceLine" id="cb83-2" title="2">  <span class="cf">if</span> (intro) {</a>
<a class="sourceLine" id="cb83-3" title="3">    <span class="kw">cat</span>(<span class="st">&quot;Voici le vecteur :</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb83-4" title="4">  }</a>
<a class="sourceLine" id="cb83-5" title="5">  <span class="kw">print</span>(<span class="kw">unclass</span>(x), ...)</a>
<a class="sourceLine" id="cb83-6" title="6">  <span class="kw">return</span>(x)</a>
<a class="sourceLine" id="cb83-7" title="7">}</a></code></pre></div>
<p>nous obtiendrions plutôt :</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb84-1" title="1"><span class="kw">print</span>(valeurs_aleatoires)</a></code></pre></div>
<pre><code>## Voici le vecteur :
## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424</code></pre>
<pre><code>## Voici le vecteur :
## [1]  0.4319268  0.4780331 -0.6331304 -0.0511430 -0.1312676 -1.1149903  0.1742424</code></pre>
<p>Une autre option serait de ne rien faire retourner à la méthode, mais le R code team juge qu’il est plus pratique qu’une méthode <code>print</code> retourne silencieusement une copie de l’objet qu’elle imprime.</p>
</div>
</div>
<div id="exemple-avec-la-méthode-générique-plot" class="section level4">
<h4>Exemple avec la méthode générique <code>plot</code></h4>

<p>Tentons maintenant de créer une méthode <code>plot</code> pour un objet de la classe <code>mon_vecteur</code>. La <a href="https://stat.ethz.ch/R-manual/R-patched/library/graphics/html/plot.html">fonction générique <code>plot</code></a> possède deux arguments, mais notre méthode reprendra uniquement son premier argument, auquel un argument supplémentaire sera ajouté. Elle générera un histogramme.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb87-1" title="1">plot.mon_vecteur &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">main =</span> <span class="st">&quot;Distribution de x&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;fréquence&quot;</span>, ...) {</a>
<a class="sourceLine" id="cb87-2" title="2">  par.default &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">1</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span>)</a>
<a class="sourceLine" id="cb87-3" title="3">  <span class="kw">on.exit</span>(<span class="kw">par</span>(par.default), <span class="dt">add =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb87-4" title="4">  out &lt;-<span class="st"> </span><span class="kw">hist</span>(<span class="dt">x =</span> x, <span class="dt">main =</span> main, <span class="dt">ylab =</span> ylab, ...)</a>
<a class="sourceLine" id="cb87-5" title="5">  <span class="kw">invisible</span>(out)</a>
<a class="sourceLine" id="cb87-6" title="6">}</a></code></pre></div>
<p>Nous avons maintenant défini deux méthodes pour la classe <code>mon_vecteur</code>.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" title="1"><span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&quot;mon_vecteur&quot;</span>)</a></code></pre></div>
<pre><code>## [1] plot  print
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>La méthode pour la fonction générique <code>plot</code> produit le résultat suivant.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" title="1"><span class="kw">plot</span>(valeurs_aleatoires)</a></code></pre></div>
<p><img src="/programmation/oop_r_2020_files/figure-html/unnamed-chunk-42-1.png" width="65%" style="display: block; margin: auto;" /></p>
<p>Si <code>valeurs_aleatoires</code> n’était pas de classe <code>mon_vecteur</code>, nous obtiendrions plutôt ce graphique.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb91-1" title="1"><span class="kw">plot</span>(<span class="kw">unclass</span>(valeurs_aleatoires))</a></code></pre></div>
<p><img src="/programmation/oop_r_2020_files/figure-html/unnamed-chunk-43-1.png" width="65%" style="display: block; margin: auto;" /></p>
<p>Cet exemple illustre le fait qu’une méthode ne doit pas obligatoirement reprendre tous les arguments de la fonction générique associée.</p>
<div id="utilité-de-lappel-à-la-fonction-on.exit" class="section level5">
<h5>Utilité de l’appel à la fonction <code>on.exit</code></h5>

<p>La <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/on.exit.html">fonction <code>on.exit</code></a> permet de s’assurer qu’une instruction est évaluée avant de terminer l’exécution d’un appel à une fonction, et ce, même si une erreur provoque l’arrêt de cette exécution avant la fin du corps de la fonction. Dans l’exemple de la méthode <code>plot.mon_vecteur</code>, le paramètre graphique <code>mar</code> (largeur des marges internes) a été modifié par un appel à la fonction <code>par</code>. Nous savons qu’une bonne pratique est de remettre les paramètres graphiques modifiés avec <code>par</code> à leurs valeurs par défaut à la fin d’un code de production d’un graphique. Lorsque ce code est dans le corps d’une fonction, il est plus prudent de programmer la remise aux valeurs par défaut par un appel à la fonction <code>on.exit</code> placé juste après l’appel à la fonction <code>par</code>.</p>
<p>De plus, spécifier l’argument <code>add = TRUE</code> dans l’appel à la fonction <code>on.exit</code> <a href="https://adv-r.hadley.nz/functions.html#on-exit">est recommandé</a> afin de permettre le cumul des instructions de fin d’exécution. Notons qu’avec un seul appel à <code>on.exit</code> dans le corps d’une fonction, cet argument n’a cependant aucun impact.</p>
</div>
</div>
</div>
<div id="méthode-print-pour-formater-limpression-des-sorties-de-nos-fonctions" class="section level3">
<h3>Méthode <code>print</code> pour formater l’impression des sorties de nos fonctions</h3>
<p>Il est souvent utile de créer des méthodes <code>print</code> pour formater l’impression des sorties de nos fonctions. Pour ce faire, il suffit de compléter les deux étapes suivantes.</p>
<ol style="list-style-type: decimal">
<li>D’abord, dans le corps de la fonction, il <strong>faut attribuer une nouvelle classe</strong>, avec la fonction <code>class</code>, à l’objet retourné en sortie.</li>
</ol>
<p>Il est pratique courante en R d’utiliser comme nom de la classe de l’objet retourné en sortie d’une fonction le nom de la fonction. C’est ce que fait par exemple la fonction <code>lm</code>. Ce n’est cependant pas obligatoire de reprendre le nom de la fonction. Le nom de la classe peut être quelconque, pourvu qu’il ne soit pas déjà utilisé par d’autres fonctions dans un package chargé afin d’éviter de modifier l’impression d’autres objets.</p>
<ol start="2" style="list-style-type: decimal">
<li>Il faut ensuite créer une fonction nommée : <code>print.nom_classe</code>.</li>
</ol>
<p>Pour illustrer ces étapes, créons une méthode <code>print</code> pour un objet retourné par la fonction <code>stats_desc</code> créée dans les notes de cours sur les <a href="https://stt4230.rbind.io/programmation/fonctions_r">fonctions</a>. Tout d’abord, attribuons une nouvelle classe à la sortie de <code>stats_desc</code>.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" title="1">stats_desc &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">format_sortie =</span> <span class="kw">c</span>(<span class="st">&quot;vecteur&quot;</span>, <span class="st">&quot;matrice&quot;</span>, <span class="st">&quot;liste&quot;</span>), ...) {</a>
<a class="sourceLine" id="cb92-2" title="2">  <span class="co"># Calcul</span></a>
<a class="sourceLine" id="cb92-3" title="3">  <span class="cf">if</span> (<span class="kw">is.numeric</span>(x)) {</a>
<a class="sourceLine" id="cb92-4" title="4">    stats &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">min =</span> <span class="kw">min</span>(x, ...), <span class="dt">moy =</span> <span class="kw">mean</span>(x, ...), <span class="dt">max =</span> <span class="kw">max</span>(x, ...))</a>
<a class="sourceLine" id="cb92-5" title="5">  } <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">is.character</span>(x) <span class="op">||</span><span class="st"> </span><span class="kw">is.factor</span>(x)) {</a>
<a class="sourceLine" id="cb92-6" title="6">    stats &lt;-<span class="st"> </span><span class="kw">table</span>(x)</a>
<a class="sourceLine" id="cb92-7" title="7">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb92-8" title="8">    stats &lt;-<span class="st"> </span><span class="ot">NA</span></a>
<a class="sourceLine" id="cb92-9" title="9">  }</a>
<a class="sourceLine" id="cb92-10" title="10">  <span class="co"># Production de la sortie</span></a>
<a class="sourceLine" id="cb92-11" title="11">  format_sortie &lt;-<span class="st"> </span><span class="kw">match.arg</span>(format_sortie)</a>
<a class="sourceLine" id="cb92-12" title="12">  <span class="cf">if</span> (format_sortie <span class="op">==</span><span class="st"> &quot;matrice&quot;</span>) {</a>
<a class="sourceLine" id="cb92-13" title="13">    stats &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(stats)</a>
<a class="sourceLine" id="cb92-14" title="14">    <span class="kw">colnames</span>(stats) &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="kw">is.character</span>(x) <span class="op">||</span><span class="st"> </span><span class="kw">is.factor</span>(x)) <span class="st">&quot;frequence&quot;</span> <span class="cf">else</span> <span class="st">&quot;stat&quot;</span></a>
<a class="sourceLine" id="cb92-15" title="15">  } <span class="cf">else</span> <span class="cf">if</span> (format_sortie <span class="op">==</span><span class="st"> &quot;liste&quot;</span>) {</a>
<a class="sourceLine" id="cb92-16" title="16">    stats &lt;-<span class="st"> </span><span class="kw">as.list</span>(stats)</a>
<a class="sourceLine" id="cb92-17" title="17">  }</a>
<a class="sourceLine" id="cb92-18" title="18">  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">stats =</span> stats)</a>
<a class="sourceLine" id="cb92-19" title="19">  <span class="kw">class</span>(out) &lt;-<span class="st"> &quot;stats_desc&quot;</span></a>
<a class="sourceLine" id="cb92-20" title="20">  out</a>
<a class="sourceLine" id="cb92-21" title="21">}</a></code></pre></div>
<p>Dans cet exemple, en plus de l’instruction <code>class(out) &lt;- "stats_desc"</code> ajoutée pour attribuer une classe à la sortie de la fonction, l’objet retourné en sortie a été formaté en liste contenant tout ce qu’il y a à retourner (ici un seul objet). Il n’est pas obligatoire qu’une sortie de fonction qui possède une classe soit une liste, mais, encore là, c’est une pratique très courante.</p>
<p>Notons que les instructions</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb93-1" title="1">  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">stats =</span> stats)</a>
<a class="sourceLine" id="cb93-2" title="2">  <span class="kw">class</span>(out) &lt;-<span class="st"> &quot;stats_desc&quot;</span></a>
<a class="sourceLine" id="cb93-3" title="3">  out</a></code></pre></div>
<p>auraient pu être remplacées par</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" title="1">  <span class="kw">structure</span>(<span class="kw">list</span>(<span class="dt">stats =</span> stats),  <span class="dt">class =</span> <span class="st">&quot;stats_desc&quot;</span>)</a></code></pre></div>
<p>Maintenant, écrivons le code de notre nouvelle méthode <code>print</code>, pour un objet de classe <code>stats_desc</code>.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" title="1">print.stats_desc &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {</a>
<a class="sourceLine" id="cb95-2" title="2">  <span class="kw">cat</span>(<span class="st">&quot;Statistiques descriptives :</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb95-3" title="3">  <span class="kw">cat</span>(<span class="st">&quot;***************************</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb95-4" title="4">  <span class="kw">print</span>(x<span class="op">$</span>stats, ...)</a>
<a class="sourceLine" id="cb95-5" title="5">  <span class="kw">cat</span>(<span class="st">&quot;***************************</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb95-6" title="6">  <span class="kw">invisible</span>(x)</a>
<a class="sourceLine" id="cb95-7" title="7">}</a></code></pre></div>
<p>Si la méthode <code>print.stats_desc</code> est appelée par <code>print</code>, c’est que l’objet donné comme premier argument à <code>print</code> est assurément de classe <code>stats_desc</code>. Ainsi, dans le corps de la méthode <code>print.stats_desc</code>, nous pouvons exploiter les caractéristiques des objets de cette classe. Nous savons qu’un objet de cette classe est une liste comportant un élément nommé <code>stats</code>. L’instruction <code>print(x$stats, ...)</code> exploite cette caractéristique.</p>
<p>Mais pourquoi cette instruction ne comporte-t-elle pas d’appel à la fonction <code>unclass</code> comme dans le corps de la méthode <code>print.mon_vecteur</code> ? Cette instruction ne provoquera-t-elle pas un appel en boucle à la méthode <code>print.stats_desc</code> ?</p>
<p>Non, parce que dans le corps de la méthode <code>print.stats_desc</code> l’objet <code>x</code> possède la classe <code>print.stats_desc</code>, mais pas le sous-objet <code>stats</code> dans <code>x</code>.</p>
<p>Pour une fonction qui retourne une très longue liste, attribuer une classe à sa sortie et écrire une méthode <code>print</code> pour cette classe permet d’éviter l’impression dans la console de la liste entière retournée en sortie.</p>
<p>Voici un exemple d’impression produit par la méthode <code>print.stats_desc</code>.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb96-1" title="1"><span class="kw">stats_desc</span>(<span class="dt">x =</span> iris<span class="op">$</span>Species, <span class="dt">format_sortie =</span> <span class="st">&quot;matrice&quot;</span>)</a></code></pre></div>
<pre><code>## Statistiques descriptives :
## ***************************
##            frequence
## setosa            50
## versicolor        50
## virginica         50
## ***************************</code></pre>
</div>
</div>
</div>
<div id="système-s4" class="section level1">
<h1>Système S4</h1>
<div id="manipulation-dobjets-dont-la-classe-est-de-type-s4" class="section level2">
<h2>Manipulation d’objets dont la classe est de type S4</h2>
<p>Même si nous n’illustrons pas ici comment créer des classes de type S4, il est bon de savoir comment utiliser ce type de classes qui est assez courant, particulièrement dans les packages distribués sur <a href="http://www.bioconductor.org/">Bioconductor</a>. Ces classes sont utilisables en R grâce au package <code>methods</code>, inclus dans l’installation de base.</p>
<p>Pour illustrer les classes de type S4, installons le package <code>sp</code>, qui exploite ce type de classe.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" title="1"><span class="kw">install.packages</span>(<span class="st">&quot;sp&quot;</span>)</a></code></pre></div>
<p>Voici un exemple d’utilisation d’une fonction de ce package, tiré d’une fiche d’aide du package.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" title="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb99-2" title="2">x =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb99-3" title="3">y =<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb99-4" title="4">S &lt;-<span class="st"> </span><span class="kw">SpatialPoints</span>(<span class="kw">cbind</span>(x, y))</a>
<a class="sourceLine" id="cb99-5" title="5">S</a></code></pre></div>
<pre><code>## SpatialPoints:
##      x y
## [1,] 1 3
## [2,] 2 2
## [3,] 3 5
## [4,] 4 1
## [5,] 5 4
## Coordinate Reference System (CRS) arguments: NA</code></pre>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb101-1" title="1"><span class="kw">str</span>(S)</a></code></pre></div>
<pre><code>## Formal class &#39;SpatialPoints&#39; [package &quot;sp&quot;] with 3 slots
##   ..@ coords     : num [1:5, 1:2] 1 2 3 4 5 3 2 5 1 4
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : NULL
##   .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
##   ..@ bbox       : num [1:2, 1:2] 1 1 5 5
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
##   .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot;
##   ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot
##   .. .. ..@ projargs: chr NA</code></pre>
<p>L’objet retourné par la fonction <code>SpatialPoints</code> n’est pas une liste. C’est un objet appartenant à une classe de type S4, définie dans le package <code>sp</code>.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" title="1"><span class="kw">isS4</span>(S)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb105-1" title="1"><span class="kw">class</span>(S)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPoints&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>Pour atteindre les éléments dans l’objet, il est possible d’utiliser une méthode conçue à cet effet. Par exemple, la fiche d’aide ouverte par la commande <a href="https://www.rdocumentation.org/packages/sp/versions/1.4-0/topics/SpatialPoints-class"><code>help("SpatialPoints-class")</code></a> nous informe qu’une méthode <code>coordinates</code> est définie pour les objets de la classe <code>"SpatialPoints"</code>. Nous pouvons aussi énumérer toutes les fonctions génériques possédant une méthode définie pour une certaine classe de type S4 avec la fonction <code>methods</code> comme suit.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" title="1"><span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&quot;SpatialPoints&quot;</span>)</a></code></pre></div>
<pre><code>##  [1] $             $&lt;-           [             [[            [[&lt;-          [&lt;-          
##  [7] addAttrToGeom as.data.frame bbox          coerce        coordinates   coordinates&lt;-
## [13] coordnames    coordnames&lt;-  dimensions    fullgrid      geometry      geometry&lt;-   
## [19] gridded       gridded&lt;-     is.projected  length        merge         over         
## [25] plot          points        polygons      print         proj4string   proj4string&lt;-
## [31] rbind         row.names     row.names&lt;-   show          spChFIDs&lt;-    split        
## [37] sppanel       spsample      spTransform   summary      
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>En fait, des méthodes de types S3 et S4 peuvent être définies pour des objets dont la classe est de type S4. La fonction <code>methods</code> retourne les méthodes des deux types. Pour se limiter à un seul type, il faut utiliser les fonctions <code>.S3methods</code> et <code>.S4methods</code>.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" title="1"><span class="kw">.S3methods</span>(<span class="dt">class =</span> <span class="st">&quot;SpatialPoints&quot;</span>)</a></code></pre></div>
<pre><code>## [1] as.data.frame length        points        print         rbind         row.names    
## [7] row.names&lt;-   split        
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" title="1"><span class="kw">.S4methods</span>(<span class="dt">class =</span> <span class="st">&quot;SpatialPoints&quot;</span>)</a></code></pre></div>
<pre><code>##  [1] $             $&lt;-           [             [[            [[&lt;-          [&lt;-          
##  [7] addAttrToGeom bbox          coerce        coordinates   coordinates&lt;- coordnames   
## [13] coordnames&lt;-  dimensions    fullgrid      geometry      geometry&lt;-    gridded      
## [19] gridded&lt;-     is.projected  merge         over          plot          polygons     
## [25] proj4string   proj4string&lt;- show          spChFIDs&lt;-    sppanel       spsample     
## [31] spTransform   summary      
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>Une fonction générique dans le système S4 n’a pas la même allure que dans le système S3.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" title="1">coordinates</a></code></pre></div>
<pre><code>## standardGeneric for &quot;coordinates&quot; defined from package &quot;sp&quot;
## 
## function (obj, ...) 
## standardGeneric(&quot;coordinates&quot;)
## &lt;bytecode: 0x000000001a237f38&gt;
## &lt;environment: 0x000000001a2164b8&gt;
## Methods may be defined for arguments: obj
## Use  showMethods(&quot;coordinates&quot;)  for currently available ones.</code></pre>
<p>La méthode <code>coordinates</code> pour un objet de classe <code>"SpatialPoints"</code> extrait l’élément de l’objet <code>S</code> nommé <code>coords</code>.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb115-1" title="1"><span class="kw">coordinates</span>(S)</a></code></pre></div>
<pre><code>##      x y
## [1,] 1 3
## [2,] 2 2
## [3,] 3 5
## [4,] 4 1
## [5,] 5 4</code></pre>
<p>Nous pouvons accéder à la définition de cette méthode grâce à la fonction <code>getMethod</code> comme suit.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb117-1" title="1"><span class="kw">getMethod</span>(coordinates, <span class="dt">signature =</span> <span class="st">&quot;SpatialPoints&quot;</span>)</a></code></pre></div>
<pre><code>## Method Definition:
## 
## function (obj, ...) 
## {
##     .local &lt;- function (obj) 
##     obj@coords
##     .local(obj, ...)
## }
## &lt;bytecode: 0x000000001a240530&gt;
## &lt;environment: namespace:sp&gt;
## 
## Signatures:
##         obj            
## target  &quot;SpatialPoints&quot;
## defined &quot;SpatialPoints&quot;</code></pre>
<p>Cette définition n’est pas aussi simple que celle d’une méthode de type S3. Je ne vais pas l’approfondir ici.</p>
<p>Pour extraire des éléments d’un objet dont la classe est de type S4, il est aussi possible d’utiliser l’opérateur <code>@</code> (et non <code>$</code> puisqu’il ne s’agit pas d’une liste).</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb119-1" title="1">S<span class="op">@</span>coords</a></code></pre></div>
<pre><code>##      x y
## [1,] 1 3
## [2,] 2 2
## [3,] 3 5
## [4,] 4 1
## [5,] 5 4</code></pre>
<p>ou encore la fonction <code>slot</code>.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb121-1" title="1"><span class="kw">slot</span>(S, <span class="st">&quot;coords&quot;</span>)</a></code></pre></div>
<pre><code>##      x y
## [1,] 1 3
## [2,] 2 2
## [3,] 3 5
## [4,] 4 1
## [5,] 5 4</code></pre>
<p>Ainsi, utiliser des classes de type S4 est simple. Il suffit de d’abord bien identifier que nous manipulons un objet dont la classe est de type S4. La mention <code>Formal class</code> dans la sortie de <code>str</code> nous l’indique. La fonction <code>isS4</code> peut aussi nous le confirmer. Ensuite, nous pouvons manipuler l’objet avec les fonctions génériques possédant des méthodes pour sa classe et nous pouvons extraire des éléments de l’objet avec l’opérateur <code>@</code> ou la fonction <code>slot</code>.</p>
<p>Notons qu’un des intérêts du package <code>sp</code> est la production facilitée de graphiques représentant des données spatiales, par exemple des coordonnées géographiques.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb123-1" title="1"><span class="kw">plot</span>(S, <span class="dt">main =</span> <span class="st">&quot;Axes sur la même échelle&quot;</span>, <span class="dt">axes=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p><img src="/programmation/oop_r_2020_files/figure-html/unnamed-chunk-59-1.png" width="65%" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb124-1" title="1"><span class="kw">plot</span>(x, y, <span class="dt">main =</span> <span class="st">&quot;Axes non contrôlés&quot;</span>)</a></code></pre></div>
<p><img src="/programmation/oop_r_2020_files/figure-html/unnamed-chunk-59-2.png" width="65%" style="display: block; margin: auto;" /></p>
<hr />
</div>
</div>
<div id="résumé" class="section level1">
<h1>Résumé</h1>
<div id="systèmes-de-programmation-orientée-objet-en-r" class="section level4">
<h4>Systèmes de programmation orientée objet en R :</h4>

<p><span class="math inline">\(\bullet\)</span> <strong>S3</strong> : le plus ancien, le moins formel, mais encore le plus utilisé.</p>
<p><span class="math inline">\(\bullet\)</span> <strong>S4</strong> : semblable au S3, mais plus formel; la norme sur Bioconductor</p>
<p>Les systèmes S3 et S4 se basent tous deux sur :</p>
<ul>
<li>des classes attribuées aux objets,</li>
<li>des fonctions génériques (ex. <code>print</code>, <code>plot</code>, <code>summary</code>, etc.),</li>
<li>des méthodes = différentes versions d’une fonction générique, associées à des classes spécifiques.
<ul>
<li>la fonction <code>methods</code> retourne les noms des :
<ul>
<li>méthodes existantes pour une fonction générique donnée ou</li>
<li>fonctions génériques possédant une méthode pour une classe donnée.</li>
</ul></li>
</ul></li>
</ul>
<p><span class="math inline">\(\bullet\)</span> <strong>Autres</strong> : <strong>RC</strong> (Reference Classes ou R5), <strong>R6</strong>, etc.<br />
<span class="math inline">\(\rightarrow\)</span> pas encore beaucoup utilisé, pas couvert dans le cours.</p>
</div>
<div id="fonctionnement-du-système-s3-1" class="section level4">
<h4>Fonctionnement du système S3</h4>

<ul>
<li>fonction générique de type S3 : appelle la fonction <code>UseMethod</code></li>
<li>méthode de type S3 = fonction dont le nom a la forme <code>nom_fonction_generique.nom_classe</code></li>
</ul>
<p>C’est la valeur retournée par la fonction <code>class</code> sur l’objet fourni comme premier argument en entrée à une fonction générique qui détermine quelle méthode est utilisée.</p>
<ul>
<li><code>class</code> retourne l’attribut <code>class</code> d’un objet, s’il existe (<em>il peut être de longueur supérieure à 1</em>).</li>
<li>Sinon <code>class</code> retourne la classe implicite de l’objet (ex. <code>"list"</code>, <code>"matrix"</code>, <code>"numeric"</code> <code>"character"</code>).</li>
<li>La méthode utilisée est celle associée à la première classe, sinon la deuxième, etc.</li>
<li>Si aucune méthode n’existe pour les classes de l’objet :
<ul>
<li>la méthode par défaut est utilisée, si elle existe;</li>
<li>sinon une erreur est retournée.</li>
</ul></li>
</ul>
</div>
<div id="création-de-classes-et-de-méthodes-de-type-s3-1" class="section level4">
<h4>Création de classes et de méthodes de type S3</h4>

<p><strong>Assignation d’une classe à un objet</strong> = ajout d’un attribut <code>class</code> à un objet</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb125-1" title="1"><span class="kw">class</span>(objet) &lt;-<span class="st"> &quot;nom_classe&quot;</span></a></code></pre></div>
<p>Pratique courante = attribuer une classe à l’objet retourné par une de nos fonctions (permet notamment de contrôler l’impression de la sortie grâce à une méthode <code>print</code>).</p>
<p><strong>Création de méthode de type S3</strong> = création de fonctions avec bon nom</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb126-1" title="1">nom_fonction_generique.nom_classe &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {</a>
<a class="sourceLine" id="cb126-2" title="2">  <span class="co"># corps de la méthode</span></a>
<a class="sourceLine" id="cb126-3" title="3">}</a></code></pre></div>
<p>où <code>nom_classe</code> peut être le nom d’une classe existante ou celui d’une nouvelle classe que nous avons créée.</p>
<p>Une méthode comporte typiquement les arguments suivants :</p>
<ul>
<li>même premier argument que la fonction générique (portant idéalement le même nom)</li>
<li>autres arguments de la fonction générique, au besoin;</li>
<li>arguments supplémentaires, au besoin;</li>
<li>l’argument <code>...</code> (même s’il n’est pas utilisé).</li>
</ul>
<p><strong>Fonctions utiles</strong> :</p>
<ul>
<li><code>unclass</code> : pour retirer l’argument <code>"class"</code> d’un objet;</li>
<li><code>invisible</code> : remplacement de <code>return</code> pour faire retourner un objet à une fonction sans provoquer l’impression de l’objet lorsque la fonction est appelée sans assignation (typiquement utilisé dans les méthodes pour les fonctions génériques <code>print</code> et <code>plot</code>);</li>
<li><code>on.exit</code> : pour s’assurer qu’une instruction est évaluée avant de terminer l’exécution d’un
appel à une fonction (p. ex. utile pour remettre à leurs valeurs par défaut des paramètres graphiques).</li>
</ul>
</div>
<div id="manipulation-dobjets-dont-la-classe-est-de-type-s4-1" class="section level4">
<h4>Manipulation d’objets dont la classe est de type S4</h4>

<ul>
<li>Caractéristiques des <strong>objets possédant une classe de type S4</strong> :
<ul>
<li>possèdent un attribut <code>class</code>;</li>
<li><code>isS4(objet)</code> retourne <code>TRUE</code>;</li>
<li>la sortie de <code>str(objet)</code> contient « <code>Formal class</code> »;</li>
<li>contiennent des éléments (<em>slots</em>) qui peuvent être extraits :
<ul>
<li>avec des méthodes conçues à cet effet,</li>
<li>avec l’opérateur <code>@</code>,</li>
<li>avec la fonction <code>slot</code>.</li>
</ul></li>
</ul></li>
<li>Caractéristiques des <strong>fonctions génériques de type S4</strong> :
<ul>
<li>appellent la fonction <code>standardGeneric</code></li>
</ul></li>
<li>Caractéristiques des <strong>méthodes de type S4</strong> :
<ul>
<li>code source affiché avec <code>getMethod(nom_fonction_generique, signature = "nom_classe")</code></li>
<li>l’impression code source contient « <code>Method Definition</code> ».</li>
</ul></li>
</ul>
<hr />
</div>
</div>
<div id="références" class="section level1">
<h1>Références</h1>
<ul>
<li>Matloff, N. (2011). <em>The Art of R Programming : A Tour of Statistical Software Design</em>. No Starch Press. Chapitre 9.</li>
<li>Wickham, H. (2019). <em>Advanced R, Second Edition</em>. Chapman and Hall/CRC. Chapitres 12 à 16. URL <a href="https://adv-r.hadley.nz/oo.html" class="uri">https://adv-r.hadley.nz/oo.html</a></li>
</ul>
</div>
